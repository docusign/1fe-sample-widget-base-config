"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReferencedTypeNames = exports.isTypeNode = void 0;
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const typeScriptHelper = [
    "Array",
    "Promise",
    "Omit",
    "Pick",
    "Record",
    "Partial",
    "Required",
];
function isTypeNode(node) {
    return (typescript_1.default.isInterfaceDeclaration(node) ||
        typescript_1.default.isTypeAliasDeclaration(node) ||
        typescript_1.default.isEnumDeclaration(node));
}
exports.isTypeNode = isTypeNode;
function getReferencedTypeNames(node, sourceFile) {
    const referenceTypeNames = new Set();
    // Adding the node name
    referenceTypeNames.add({ name: node.name.text, partOfQualifiedName: false });
    const visitorExtract = (child) => {
        if (typescript_1.default.isPropertySignature(child)) {
            const childNode = child;
            if (childNode.type) {
                handleTypeNode(childNode.type);
            }
        }
        else if (typescript_1.default.isIndexSignatureDeclaration(child) && child.type) {
            handleTypeNode(child.type);
        }
    };
    const handleTypeNode = (typeNode) => {
        if (typescript_1.default.isParenthesizedTypeNode(typeNode)) {
            typeNode = typeNode.type;
        }
        if (typescript_1.default.isTypeReferenceNode(typeNode)) {
            handleTypeReferenceNode(typeNode);
        }
        else if (typescript_1.default.isArrayTypeNode(typeNode)) {
            handleTypeNode(typeNode.elementType);
        }
        else if (typescript_1.default.isTypeLiteralNode(typeNode)) {
            typeNode.forEachChild(visitorExtract);
        }
        else if (typescript_1.default.isTupleTypeNode(typeNode)) {
            typeNode.elements.forEach(handleTypeNode);
        }
        else if (typescript_1.default.isRestTypeNode(typeNode)) {
            handleTypeNode(typeNode.type);
        }
        else if (typescript_1.default.isIntersectionTypeNode(typeNode) ||
            typescript_1.default.isUnionTypeNode(typeNode)) {
            typeNode.types.forEach(handleTypeNode);
        }
        else if (typescript_1.default.isIndexedAccessTypeNode(typeNode)) {
            handleTypeNode(typeNode.objectType);
        }
    };
    const handleTypeReferenceNode = (typeRefNode) => {
        if (typescript_1.default.isQualifiedName(typeRefNode.typeName)) {
            const typeName = typeRefNode.typeName.left.getText(sourceFile);
            referenceTypeNames.add({ name: typeName, partOfQualifiedName: true });
            return;
        }
        const typeName = typeRefNode.typeName.getText(sourceFile);
        if (typeScriptHelper.indexOf(typeName) > -1 && typeRefNode.typeArguments) {
            typeRefNode.typeArguments.forEach((t) => handleTypeNode(t));
            return;
        }
        referenceTypeNames.add({ name: typeName, partOfQualifiedName: false });
    };
    if (typescript_1.default.isInterfaceDeclaration(node)) {
        const heritageClauses = node.heritageClauses;
        if (heritageClauses) {
            heritageClauses.forEach((clause) => {
                const extensionTypes = clause.types;
                extensionTypes.forEach((extensionTypeNode) => {
                    const typeName = extensionTypeNode.expression.getText(sourceFile);
                    if (extensionTypeNode.typeArguments) {
                        extensionTypeNode.typeArguments.forEach((t) => handleTypeNode(t));
                    }
                    if (typeScriptHelper.indexOf(typeName) === -1) {
                        referenceTypeNames.add({
                            name: typeName,
                            partOfQualifiedName: false,
                        });
                    }
                });
            });
        }
        node.forEachChild(visitorExtract);
    }
    else if (typescript_1.default.isTypeAliasDeclaration(node)) {
        handleTypeNode(node.type);
    }
    return Array.from(referenceTypeNames);
}
exports.getReferencedTypeNames = getReferencedTypeNames;
//# sourceMappingURL=traverseTypes.js.map