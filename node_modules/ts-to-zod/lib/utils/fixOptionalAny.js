"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixOptionalAny = void 0;
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importStar(require("typescript"));
/**
 * Add optional property to `any`, `undefined` or imported types to workaround comparison issue.
 *
 * ref:
 * -> https://github.com/fabien0102/ts-to-zod/issues/140
 * -> https://github.com/fabien0102/ts-to-zod/issues/203
 * -> https://github.com/fabien0102/ts-to-zod/issues/239
 *
 */
function fixOptionalAny(sourceFile, importsToHandleAsAny) {
    function shouldAddQuestionToken(node) {
        return (
        // https://github.com/fabien0102/ts-to-zod/issues/140
        node.kind === typescript_1.default.SyntaxKind.AnyKeyword ||
            // https://github.com/fabien0102/ts-to-zod/issues/239
            node.kind === typescript_1.default.SyntaxKind.UndefinedKeyword ||
            // Handling type referencing imported types
            // https://github.com/fabien0102/ts-to-zod/issues/203
            (typescript_1.default.isTypeReferenceNode(node) &&
                importsToHandleAsAny.has(node.typeName.getText(sourceFile))));
    }
    const markAnyAsOptional = (context) => {
        const visit = (node) => {
            node = typescript_1.default.visitEachChild(node, visit, context);
            if (typescript_1.default.isPropertySignature(node) && node.type) {
                const typeNode = node.type;
                if (shouldAddQuestionToken(typeNode)) {
                    return createOptionalPropertyNode(node);
                }
                // Handling nested Any / TypeReference
                if (typescript_1.default.isUnionTypeNode(typeNode) ||
                    typescript_1.default.isIntersectionTypeNode(typeNode)) {
                    const withQuestionToken = typeNode.types.filter((childNode) => shouldAddQuestionToken(childNode));
                    if (withQuestionToken.length > 0)
                        return createOptionalPropertyNode(node);
                }
            }
            return node;
        };
        return (sourceFile) => typescript_1.default.visitNode(sourceFile, visit);
    };
    // Apply transformation
    const outputFile = typescript_1.default.transform(sourceFile, [markAnyAsOptional]);
    // Printing the transformed file
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    return printer.printFile(outputFile.transformed[0]);
}
exports.fixOptionalAny = fixOptionalAny;
function createOptionalPropertyNode(node) {
    return typescript_1.default.factory.createPropertySignature(node.modifiers, node.name, typescript_1.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken), // Add `questionToken`
    node.type);
}
//# sourceMappingURL=fixOptionalAny.js.map