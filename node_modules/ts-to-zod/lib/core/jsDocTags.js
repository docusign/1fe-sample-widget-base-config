"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsDocTagToZodProperties = exports.getJSDocTags = void 0;
const tslib_1 = require("tslib");
const tsutils_1 = require("tsutils");
const typescript_1 = tslib_1.__importStar(require("typescript"));
/**
 * List of formats that can be translated in zod functions.
 */
const builtInJSDocFormatsTypes = [
    "date-time",
    "date",
    "time",
    "duration",
    "email",
    "ip",
    "ipv4",
    "ipv6",
    "url",
    "uuid",
    // "uri",
];
/**
 * Type guard to filter supported JSDoc format tag values (built-in).
 *
 * @param formatType
 */
function isBuiltInFormatType(formatType = "") {
    return builtInJSDocFormatsTypes.map(String).includes(formatType);
}
/**
 * Type guard to filter supported JSDoc format tag values (custom).
 *
 * @param formatType
 * @param customFormatTypes
 */
function isCustomFormatType(formatType = "", customFormatTypes) {
    return customFormatTypes.includes(formatType);
}
const jsDocTagKeys = [
    "description",
    "minimum",
    "maximum",
    "default",
    "minLength",
    "maxLength",
    "format",
    "pattern",
    "schema",
    "elementDescription",
    "elementMinimum",
    "elementMaximum",
    "elementMinLength",
    "elementMaxLength",
    "elementPattern",
    "elementFormat",
    "discriminator",
];
/**
 * Type guard to filter supported JSDoc tag key.
 *
 * @param tagName
 */
function isJSDocTagKey(tagName) {
    return jsDocTagKeys.map(String).includes(tagName);
}
/**
 * Parse js doc comment.
 *
 * @example
 * parseJsDocComment("email should be an email");
 * // {value: "email", errorMessage: "should be an email"}
 *
 * @param comment
 */
function parseJsDocComment(comment) {
    const [value, ...rest] = comment.split(" ");
    const errorMessage = rest.join(" ").replace(/(^["']|["']$)/g, "") || undefined;
    return {
        value: value.replace(",", "").replace(/(^["']|["']$)/g, ""),
        errorMessage,
    };
}
/**
 * Return parsed JSTags.
 *
 * This function depends on `customJSDocFormatTypeContext`. Before
 * calling it, make sure the context has been supplied the expected value.
 *
 * @param nodeType
 * @param sourceFile
 * @returns Tags list
 */
function getJSDocTags(nodeType, sourceFile) {
    const jsDoc = (0, tsutils_1.getJsDoc)(nodeType, sourceFile);
    const jsDocTags = {};
    if (jsDoc.length) {
        jsDoc.forEach((doc) => {
            (doc.tags || []).forEach((tag) => {
                const tagName = tag.tagName.escapedText.toString();
                // Handling "unary operator" tag first (no tag.comment part needed)
                if (tagName === "strict") {
                    jsDocTags[tagName] = true;
                    return;
                }
                if (!isJSDocTagKey(tagName) || typeof tag.comment !== "string")
                    return;
                const { value, errorMessage } = parseJsDocComment(tag.comment);
                switch (tagName) {
                    case "minimum":
                    case "maximum":
                    case "minLength":
                    case "maxLength":
                    case "elementMinLength":
                    case "elementMaxLength":
                    case "elementMinimum":
                    case "elementMaximum":
                        if (value && !Number.isNaN(parseInt(value))) {
                            jsDocTags[tagName] = { value: parseInt(value), errorMessage };
                        }
                        break;
                    case "description":
                    case "elementDescription":
                    case "schema":
                    case "pattern":
                    case "elementPattern":
                        if (tag.comment) {
                            jsDocTags[tagName] = tag.comment;
                        }
                        break;
                    case "format":
                    case "elementFormat":
                        jsDocTags[tagName] = { value, errorMessage };
                        break;
                    case "default":
                        if (tag.comment) {
                            try {
                                // Attempt to parse as JSON
                                const parsedValue = JSON.parse(tag.comment);
                                jsDocTags[tagName] = parsedValue;
                            }
                            catch (e) {
                                // If JSON parsing fails, handle as before
                                jsDocTags[tagName] = tag.comment;
                            }
                        }
                        break;
                    case "discriminator":
                        jsDocTags[tagName] = tag.comment;
                        break;
                    case "strict":
                        break;
                    default:
                        tagName;
                }
            });
        });
    }
    return jsDocTags;
}
exports.getJSDocTags = getJSDocTags;
/**
 * Convert a set of JSDoc tags to zod properties.
 *
 * @param jsDocTags
 * @param customJSDocFormats
 * @param isOptional
 * @param isPartial
 * @param isRequired
 * @param isNullable
 */
function jsDocTagToZodProperties(jsDocTags, customJSDocFormats, isOptional, isPartial, isRequired, isNullable) {
    const zodProperties = [];
    if (jsDocTags.minimum !== undefined) {
        zodProperties.push({
            identifier: "min",
            expressions: withErrorMessage(jsDocTags.minimum.value < 0
                ? typescript_1.factory.createPrefixUnaryExpression(typescript_1.default.SyntaxKind.MinusToken, typescript_1.factory.createNumericLiteral(Math.abs(jsDocTags.minimum.value)))
                : typescript_1.factory.createNumericLiteral(jsDocTags.minimum.value), jsDocTags.minimum.errorMessage),
        });
    }
    if (jsDocTags.maximum !== undefined) {
        zodProperties.push({
            identifier: "max",
            expressions: withErrorMessage(jsDocTags.maximum.value < 0
                ? typescript_1.factory.createPrefixUnaryExpression(typescript_1.default.SyntaxKind.MinusToken, typescript_1.factory.createNumericLiteral(Math.abs(jsDocTags.maximum.value)))
                : typescript_1.factory.createNumericLiteral(jsDocTags.maximum.value), jsDocTags.maximum.errorMessage),
        });
    }
    if (jsDocTags.minLength !== undefined) {
        zodProperties.push({
            identifier: "min",
            expressions: withErrorMessage(typescript_1.factory.createNumericLiteral(jsDocTags.minLength.value), jsDocTags.minLength.errorMessage),
        });
    }
    if (jsDocTags.maxLength !== undefined) {
        zodProperties.push({
            identifier: "max",
            expressions: withErrorMessage(typescript_1.factory.createNumericLiteral(jsDocTags.maxLength.value), jsDocTags.maxLength.errorMessage),
        });
    }
    if (jsDocTags.format &&
        (isBuiltInFormatType(jsDocTags.format.value) ||
            isCustomFormatType(jsDocTags.format.value, Object.keys(customJSDocFormats)))) {
        zodProperties.push(formatToZodProperty(jsDocTags.format, customJSDocFormats));
    }
    if (jsDocTags.pattern) {
        zodProperties.push(createZodRegexProperty(jsDocTags.pattern));
    }
    // strict() must be before optional() and nullable()
    if (jsDocTags.strict) {
        zodProperties.push({ identifier: "strict" });
    }
    // partial() must be before optional() and nullable()
    if (isPartial) {
        zodProperties.push({
            identifier: "partial",
        });
    }
    if (isOptional) {
        zodProperties.push({
            identifier: "optional",
        });
    }
    if (isNullable || jsDocTags.default === null) {
        zodProperties.push({
            identifier: "nullable",
        });
    }
    if (isRequired) {
        zodProperties.push({
            identifier: "required",
        });
    }
    if (jsDocTags.description !== undefined) {
        zodProperties.push({
            identifier: "describe",
            expressions: [typescript_1.factory.createStringLiteral(jsDocTags.description)],
        });
    }
    if (jsDocTags.default !== undefined) {
        zodProperties.push({
            identifier: "default",
            expressions: jsDocTags.default === true
                ? [typescript_1.factory.createTrue()]
                : jsDocTags.default === false
                    ? [typescript_1.factory.createFalse()]
                    : typeof jsDocTags.default === "number"
                        ? jsDocTags.default < 0
                            ? [
                                typescript_1.factory.createPrefixUnaryExpression(typescript_1.default.SyntaxKind.MinusToken, typescript_1.factory.createNumericLiteral(Math.abs(jsDocTags.default))),
                            ]
                            : [typescript_1.factory.createNumericLiteral(jsDocTags.default)]
                        : jsDocTags.default === null
                            ? [typescript_1.factory.createNull()]
                            : Array.isArray(jsDocTags.default)
                                ? [createArrayLiteralExpression(jsDocTags.default)]
                                : typeof jsDocTags.default === "object"
                                    ? [createObjectLiteralExpression(jsDocTags.default)]
                                    : [typescript_1.factory.createStringLiteral(String(jsDocTags.default))],
        });
    }
    return zodProperties;
}
exports.jsDocTagToZodProperties = jsDocTagToZodProperties;
/**
 * Converts the given JSDoc format to the corresponding Zod
 * string validation function call represented by a {@link ZodProperty}.
 *
 * @param format The format to be converted.
 * @returns A ZodProperty representing a Zod string validation function call.
 */
function formatToZodProperty(format, customFormatTypes) {
    var _a;
    if (isCustomFormatType(format.value, Object.keys(customFormatTypes))) {
        const rule = customFormatTypes[format.value];
        const regex = typeof rule === "string" ? rule : rule.regex;
        const errorMessage = typeof rule === "string" ? undefined : rule.errorMessage;
        return createZodRegexProperty(regex, (_a = format.errorMessage) !== null && _a !== void 0 ? _a : errorMessage);
    }
    const identifier = builtInFormatTypeToZodPropertyIdentifier(format.value);
    const expressions = builtInFormatTypeToZodPropertyArguments(format.value, format.errorMessage);
    return { identifier, expressions };
}
/**
 * Maps the given JSDoc format type to its corresponding
 * Zod string validation function name.
 *
 * @param formatType The format type to be converted.
 * @returns The name of a Zod string validation function.
 */
function builtInFormatTypeToZodPropertyIdentifier(formatType) {
    switch (formatType) {
        case "date-time":
            return "datetime";
        case "ipv4":
        case "ipv6":
        case "ip":
            return "ip";
        default:
            return formatType;
    }
}
/**
 * Maps the given JSDoc format type and error message to the
 * expected Zod string validation function arguments.
 *
 * @param formatType The format type to be converted.
 * @param errorMessage The error message to display if validation fails.
 * @returns A list of expressions which represent function arguments.
 */
function builtInFormatTypeToZodPropertyArguments(formatType, errorMessage) {
    switch (formatType) {
        case "ipv4":
            return createZodStringIpArgs("v4", errorMessage);
        case "ipv6":
            return createZodStringIpArgs("v6", errorMessage);
        default:
            return errorMessage ? [typescript_1.factory.createStringLiteral(errorMessage)] : undefined;
    }
}
/**
 * Constructs a list of expressions which represent the arguments
 * for `ip()` string validation function.
 *
 * @param version The IP version to use.
 * @param errorMessage The error message to display if validation fails.
 * @returns A list of expressions which represent the function arguments.
 */
function createZodStringIpArgs(version, errorMessage) {
    const propertyAssignments = [
        typescript_1.factory.createPropertyAssignment("version", typescript_1.factory.createStringLiteral(version)),
    ];
    if (errorMessage) {
        propertyAssignments.push(typescript_1.factory.createPropertyAssignment("message", typescript_1.factory.createStringLiteral(errorMessage)));
    }
    return [typescript_1.factory.createObjectLiteralExpression(propertyAssignments)];
}
/**
 * Constructs a ZodProperty that represents a call to
 * `.regex()` with the given regular expression.
 *
 * @param regex The regular expression to match.
 * @param errorMessage The error message to display if validation fails.
 * @returns A ZodProperty representing a `.regex()` call.
 */
function createZodRegexProperty(regex, errorMessage) {
    return {
        identifier: "regex",
        expressions: withErrorMessage(typescript_1.factory.createRegularExpressionLiteral(`/${regex}/`), errorMessage),
    };
}
function withErrorMessage(expression, errorMessage) {
    if (errorMessage) {
        return [expression, typescript_1.factory.createStringLiteral(errorMessage)];
    }
    return [expression];
}
// Helper function to create an array literal expression
function createArrayLiteralExpression(arr) {
    const elements = arr.map((item) => {
        if (typeof item === "string")
            return typescript_1.factory.createStringLiteral(item);
        if (typeof item === "number")
            return typescript_1.factory.createNumericLiteral(item);
        if (typeof item === "boolean")
            return item ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse();
        if (item === null)
            return typescript_1.factory.createNull();
        if (Array.isArray(item))
            return createArrayLiteralExpression(item);
        if (typeof item === "object")
            return createObjectLiteralExpression(item);
        return typescript_1.factory.createStringLiteral(String(item));
    });
    return typescript_1.factory.createArrayLiteralExpression(elements);
}
// Helper function to create an object literal expression
function createObjectLiteralExpression(obj) {
    const properties = Object.entries(obj).map(([key, value]) => {
        const propertyName = typescript_1.factory.createStringLiteral(key);
        if (typeof value === "string")
            return typescript_1.factory.createPropertyAssignment(propertyName, typescript_1.factory.createStringLiteral(value));
        if (typeof value === "number")
            return typescript_1.factory.createPropertyAssignment(propertyName, typescript_1.factory.createNumericLiteral(value));
        if (typeof value === "boolean")
            return typescript_1.factory.createPropertyAssignment(propertyName, value ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse());
        if (value === null)
            return typescript_1.factory.createPropertyAssignment(propertyName, typescript_1.factory.createNull());
        if (Array.isArray(value))
            return typescript_1.factory.createPropertyAssignment(propertyName, createArrayLiteralExpression(value));
        if (typeof value === "object")
            return typescript_1.factory.createPropertyAssignment(propertyName, createObjectLiteralExpression(value));
        return typescript_1.factory.createPropertyAssignment(propertyName, typescript_1.factory.createStringLiteral(String(value)));
    });
    return typescript_1.factory.createObjectLiteralExpression(properties);
}
//# sourceMappingURL=jsDocTags.js.map