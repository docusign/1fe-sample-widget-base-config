"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const tslib_1 = require("tslib");
const case_1 = require("case");
const tsutils_1 = require("tsutils");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const getSimplifiedJsDocTags_1 = require("../utils/getSimplifiedJsDocTags");
const resolveModules_1 = require("../utils/resolveModules");
const traverseTypes_1 = require("../utils/traverseTypes");
const importHandling_1 = require("../utils/importHandling");
const generateIntegrationTests_1 = require("./generateIntegrationTests");
const generateZodInferredType_1 = require("./generateZodInferredType");
const generateZodSchema_1 = require("./generateZodSchema");
const transformRecursiveSchema_1 = require("./transformRecursiveSchema");
const getImportPath_1 = require("../utils/getImportPath");
const DEFAULT_GET_SCHEMA = (id) => (0, case_1.camel)(id) + "Schema";
/**
 * Generate zod schemas and integration tests from a typescript file.
 *
 * This function takes care of the sorting of the `const` declarations and solves potential circular references
 */
function generate({ sourceText, nameFilter = () => true, jsDocTagFilter = () => true, getSchemaName = DEFAULT_GET_SCHEMA, keepComments = false, skipParseJSDoc = false, customJSDocFormatTypes = {}, inputOutputMappings = [], }) {
    // Create a source file and deal with modules
    const sourceFile = (0, resolveModules_1.resolveModules)(sourceText);
    // Extract the nodes (interface declarations & type aliases)
    const nodes = [];
    // declare a map to store the interface name and its corresponding zod schema
    const typeNameMapping = new Map();
    /**
     * Following const are keeping track of all the things import-related
     */
    // All import nodes in the source file
    const zodImportNodes = [];
    // Keep track of all the external import names available in the source file
    const externalImportNamesAvailable = new Set();
    // Keep track of all the imports that have an entry in the config file
    const importedZodNamesAvailable = new Map();
    // Keep track of all referenced types in the source file
    const candidateTypesToBeExtracted = new Set();
    const typeNameMapBuilder = (node) => {
        if ((0, traverseTypes_1.isTypeNode)(node)) {
            typeNameMapping.set(node.name.text, node);
            return;
        }
        if (typescript_1.default.isImportDeclaration(node) && node.importClause) {
            const identifiers = (0, importHandling_1.getImportIdentifiers)(node);
            identifiers.forEach(({ name }) => typeNameMapping.set(name, node));
            // Check if we're importing from a mapped file
            const eligibleMapping = inputOutputMappings.find((io) => (0, getImportPath_1.areImportPathsEqualIgnoringExtension)(io.input, node.moduleSpecifier.text));
            if (eligibleMapping) {
                const schemaMethod = eligibleMapping.getSchemaName || DEFAULT_GET_SCHEMA;
                identifiers.forEach(({ name }) => importedZodNamesAvailable.set(name, schemaMethod(name)));
                const zodImportNode = (0, importHandling_1.createImportNode)(identifiers.map(({ name, original }) => {
                    return {
                        name: schemaMethod(name),
                        original: original ? schemaMethod(original) : undefined,
                    };
                }), eligibleMapping.output);
                zodImportNodes.push(zodImportNode);
            }
            // Not a Zod import, handling it as 3rd party import later on
            else {
                identifiers.forEach(({ name }) => externalImportNamesAvailable.add(name));
            }
        }
    };
    typescript_1.default.forEachChild(sourceFile, typeNameMapBuilder);
    const visitor = (node) => {
        if (typescript_1.default.isInterfaceDeclaration(node) ||
            typescript_1.default.isTypeAliasDeclaration(node) ||
            typescript_1.default.isEnumDeclaration(node)) {
            const jsDoc = (0, tsutils_1.getJsDoc)(node, sourceFile);
            const tags = (0, getSimplifiedJsDocTags_1.getSimplifiedJsDocTags)(jsDoc);
            if (!jsDocTagFilter(tags))
                return;
            if (!nameFilter(node.name.text))
                return;
            const typeNames = (0, traverseTypes_1.getReferencedTypeNames)(node, sourceFile);
            typeNames.forEach((typeRef) => {
                candidateTypesToBeExtracted.add(typeRef);
            });
        }
    };
    typescript_1.default.forEachChild(sourceFile, visitor);
    // All external import names actually used in the source file
    const importNamesUsed = [];
    // All zod imports actually used in the source file
    const importedZodSchemas = new Set();
    // All original import to keep in the target
    const importsToKeep = new Map();
    /**
     * We browse all the extracted type references from the source file
     * To check if they reference a node from the file or if they are imported
     */
    candidateTypesToBeExtracted.forEach((typeRef) => {
        const node = typeNameMapping.get(typeRef.name);
        if (node) {
            // If we have a reference in the file, we add it to the nodes, no import needed
            if ((0, traverseTypes_1.isTypeNode)(node)) {
                nodes.push(node);
                return;
            }
            // If the reference is part of a qualified name, we need to import it from the same file
            if (typeRef.partOfQualifiedName) {
                const identifiers = importsToKeep.get(node);
                const importIdentifier = (0, importHandling_1.getSingleImportIdentierForNode)(node, typeRef.name);
                if (!importIdentifier)
                    return;
                if (identifiers) {
                    identifiers.push(importIdentifier);
                }
                else {
                    importsToKeep.set(node, [importIdentifier]);
                }
                return;
            }
        }
        // If the reference is coming from an external import, we'll need to generate a specific statement
        // and keep the external import
        if (externalImportNamesAvailable.has(typeRef.name)) {
            importNamesUsed.push(typeRef.name);
            return;
        }
        // If the reference is coming from a mapped import, we'll import the corresponding zod schema
        if (importedZodNamesAvailable.has(typeRef.name)) {
            importedZodSchemas.add(importedZodNamesAvailable.get(typeRef.name));
            return;
        }
    });
    // Generate zod schemas for type nodes
    const getDependencyName = (identifierName) => {
        if (importedZodNamesAvailable.has(identifierName)) {
            return importedZodNamesAvailable.get(identifierName);
        }
        return getSchemaName(identifierName);
    };
    const zodTypeSchemas = nodes.map((node) => {
        const typeName = node.name.text;
        const varName = getSchemaName(typeName);
        const zodSchema = (0, generateZodSchema_1.generateZodSchemaVariableStatement)({
            zodImportValue: "z",
            node,
            sourceFile,
            varName,
            getDependencyName: getDependencyName,
            skipParseJSDoc,
            customJSDocFormatTypes,
        });
        return Object.assign({ typeName, varName }, zodSchema);
    });
    // Generate zod schemas for 3rd party imports
    const zodImportSchemas = importNamesUsed.map((importName) => {
        const varName = getSchemaName(importName);
        return {
            dependencies: [],
            statement: (0, generateZodSchema_1.generateZodSchemaVariableStatementForImport)({
                varName,
                zodImportValue: "z",
            }),
            enumImport: false,
            typeName: importName,
            varName,
        };
    });
    const zodSchemas = zodTypeSchemas.concat(zodImportSchemas);
    const zodSchemaNames = zodSchemas.map(({ varName }) => varName);
    // Resolves statements order
    // A schema can't be declared if all the referenced schemas used inside this one are not previously declared.
    const statements = new Map();
    // Keep track of types/enums which need to be imported from the source file
    const sourceTypeImports = new Set();
    const sourceEnumImports = new Set();
    // Zod schemas with direct or indirect dependencies that are not in `zodSchemas`, won't be generated
    const zodSchemasWithMissingDependencies = new Set();
    let done = false;
    // Loop until no more schemas can be generated and no more schemas with direct or indirect missing dependencies are found
    while (!done &&
        statements.size + zodSchemasWithMissingDependencies.size !==
            zodSchemas.length) {
        done = true;
        zodSchemas
            .filter(({ varName }) => !statements.has(varName) &&
            !zodSchemasWithMissingDependencies.has(varName))
            .forEach(({ varName, dependencies, statement, typeName, enumImport }) => {
            const isCircular = dependencies.includes(varName);
            const notGeneratedDependencies = dependencies
                .filter((dep) => dep !== varName)
                .filter((dep) => !statements.has(dep))
                .filter((dep) => !importedZodSchemas.has(dep));
            if (notGeneratedDependencies.length === 0) {
                done = false;
                if (isCircular) {
                    sourceTypeImports.add(typeName);
                    statements.set(varName, {
                        value: (0, transformRecursiveSchema_1.transformRecursiveSchema)("z", statement, typeName),
                        typeName,
                    });
                }
                else {
                    if (enumImport) {
                        sourceEnumImports.add(typeName);
                    }
                    statements.set(varName, { value: statement, typeName });
                }
            }
            else if (
            // Check if every dependency is (in `zodSchemas` and not in `zodSchemasWithMissingDependencies`)
            !notGeneratedDependencies.every((dep) => zodSchemaNames.includes(dep) &&
                !zodSchemasWithMissingDependencies.has(dep))) {
                done = false;
                zodSchemasWithMissingDependencies.add(varName);
            }
        });
    }
    // Generate remaining schemas, which have circular dependencies with loop of length > 1 like: A->B—>C->A
    zodSchemas
        .filter(({ varName }) => !statements.has(varName) &&
        !zodSchemasWithMissingDependencies.has(varName))
        .forEach(({ varName, statement, typeName }) => {
        sourceTypeImports.add(typeName);
        statements.set(varName, {
            value: (0, transformRecursiveSchema_1.transformRecursiveSchema)("z", statement, typeName),
            typeName,
        });
    });
    // Warn the user of possible not resolvable loops
    const errors = [];
    if (zodSchemasWithMissingDependencies.size > 0) {
        errors.push(`Some schemas can't be generated due to direct or indirect missing dependencies:
${Array.from(zodSchemasWithMissingDependencies).join("\n")}`);
    }
    // Create output files (zod schemas & integration tests)
    const printer = typescript_1.default.createPrinter({
        newLine: typescript_1.default.NewLineKind.LineFeed,
        removeComments: !keepComments,
    });
    const printerWithComments = typescript_1.default.createPrinter({
        newLine: typescript_1.default.NewLineKind.LineFeed,
    });
    const print = (node) => printer.printNode(typescript_1.default.EmitHint.Unspecified, node, sourceFile);
    const transformedSourceText = printerWithComments.printFile(sourceFile);
    const zodImportToOutput = zodImportNodes.filter((node) => {
        const nodeIdentifiers = (0, importHandling_1.getImportIdentifiers)(node);
        return nodeIdentifiers.some(({ name }) => importedZodSchemas.has(name));
    });
    const originalImportsToOutput = Array.from(importsToKeep.keys()).map((node) => (0, importHandling_1.createImportNode)(importsToKeep.get(node), node.moduleSpecifier.text));
    const sourceTypeImportsValues = [
        ...sourceTypeImports.values(),
        ...sourceEnumImports.values(),
    ].map((name) => {
        return sourceEnumImports.has(name)
            ? name // enum import, no type notation added
            : `type ${name}`;
    });
    const getZodSchemasFile = (typesImportPath) => `// Generated by ts-to-zod
import { z } from "zod";
${sourceTypeImportsValues.length
        ? `import { ${sourceTypeImportsValues.join(", ")} } from "${typesImportPath}";\n`
        : ""}
${zodImportToOutput.length
        ? zodImportToOutput.map((node) => print(node)).join("\n") + "\n\n"
        : ""}${originalImportsToOutput.length
        ? originalImportsToOutput.map((node) => print(node)).join("\n") + "\n\n"
        : ""}${Array.from(statements.values())
        .map((statement) => print(statement.value))
        .join("\n\n")}
`;
    const testCases = (0, generateIntegrationTests_1.generateIntegrationTests)(Array.from(statements.values())
        .filter(isExported)
        .map((i) => ({
        zodType: `${getSchemaName(i.typeName)}InferredType`,
        tsType: `spec.${i.typeName}`,
    })));
    const getIntegrationTestFile = (typesImportPath, zodSchemasImportPath) => `// Generated by ts-to-zod
import { z } from "zod";

import * as spec from "${typesImportPath}";
import * as generated from "${zodSchemasImportPath}";

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function expectType<T>(_: T) {
  /* noop */
}

${Array.from(statements.values())
        .filter(isExported)
        .map((statement) => {
        // Generate z.infer<>
        const zodInferredSchema = (0, generateZodInferredType_1.generateZodInferredType)({
            aliasName: `${getSchemaName(statement.typeName)}InferredType`,
            zodConstName: `generated.${getSchemaName(statement.typeName)}`,
            zodImportValue: "z",
        });
        return print(zodInferredSchema);
    })
        .join("\n\n")}

${testCases.map(print).join("\n")}
`;
    const getInferredTypes = (zodSchemasImportPath) => `// Generated by ts-to-zod
import { z } from "zod";

import * as generated from "${zodSchemasImportPath}";

${Array.from(statements.values())
        .filter(isExported)
        .map((statement) => {
        const zodInferredSchema = (0, generateZodInferredType_1.generateZodInferredType)({
            aliasName: statement.typeName,
            zodConstName: `generated.${getSchemaName(statement.typeName)}`,
            zodImportValue: "z",
        });
        return print(zodInferredSchema);
    })
        .join("\n\n")}
`;
    return {
        /**
         * Source text with pre-process applied.
         */
        transformedSourceText,
        /**
         * Get the content of the zod schemas file.
         *
         * @param typesImportPath Relative path of the source file
         */
        getZodSchemasFile,
        /**
         * Get the content of the integration tests file.
         *
         * @param typesImportPath Relative path of the source file
         * @param zodSchemasImportPath Relative path of the zod schemas file
         */
        getIntegrationTestFile,
        /**
         * Get the content of the zod inferred types files.
         *
         * @param zodSchemasImportPath Relative path of the zod schemas file
         */
        getInferredTypes,
        /**
         * List of generation errors.
         */
        errors,
        /**
         * `true` if zodSchemaFile have some resolvable circular dependencies
         */
        hasCircularDependencies: sourceTypeImportsValues.length > 0,
    };
}
exports.generate = generate;
/**
 * Helper to filter exported const declaration
 * @param i
 * @returns
 */
const isExported = (i) => { var _a; return (_a = i.value.modifiers) === null || _a === void 0 ? void 0 : _a.find((mod) => mod.kind === typescript_1.default.SyntaxKind.ExportKeyword); };
//# sourceMappingURL=generate.js.map