#!/usr/bin/env node
'use strict';

var extraTypings = require('@commander-js/extra-typings');
var webpack = require('webpack');
var tsconfigPathsWebpackPlugin = require('tsconfig-paths-webpack-plugin');
var webpackMerge = require('webpack-merge');
var lodash = require('lodash');
var path = require('path');
var fs = require('fs');
var chalk4 = require('chalk');
var zodValidationError = require('zod-validation-error');
var zod = require('zod');
var ky = require('ky');
var SystemJSPublicPathWebpackPlugin = require('systemjs-webpack-interop/SystemJSPublicPathWebpackPlugin');
var WebpackBar = require('webpackbar');
var webpackBundleAnalyzer = require('webpack-bundle-analyzer');
var ReactRefreshPlugin = require('@pmmmwh/react-refresh-webpack-plugin');
var ejs = require('ejs');
var globby = require('globby');
var VirtualModulesPlugin = require('webpack-virtual-modules');
var fsExtra = require('fs-extra');
var promises = require('fs/promises');
var os = require('os');
var child_process = require('child_process');
var util = require('util');
var apiExtractor = require('@microsoft/api-extractor');
var WebpackDevServer = require('webpack-dev-server');
var getPorts = require('webpack-dev-server/lib/getPort');
var open = require('open');
var semver = require('semver');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var chalk4__default = /*#__PURE__*/_interopDefault(chalk4);
var ky__default = /*#__PURE__*/_interopDefault(ky);
var SystemJSPublicPathWebpackPlugin__default = /*#__PURE__*/_interopDefault(SystemJSPublicPathWebpackPlugin);
var WebpackBar__default = /*#__PURE__*/_interopDefault(WebpackBar);
var ReactRefreshPlugin__default = /*#__PURE__*/_interopDefault(ReactRefreshPlugin);
var ejs__default = /*#__PURE__*/_interopDefault(ejs);
var VirtualModulesPlugin__default = /*#__PURE__*/_interopDefault(VirtualModulesPlugin);
var WebpackDevServer__default = /*#__PURE__*/_interopDefault(WebpackDevServer);
var getPorts__default = /*#__PURE__*/_interopDefault(getPorts);
var open__default = /*#__PURE__*/_interopDefault(open);

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var getKnownPaths = lodash.memoize(function getPathsRaw(projectDir = process.cwd()) {
  const reportsDir = path.join(projectDir, "reports");
  const srcDir = path.join(projectDir, "src");
  const cacheDir = path.join(projectDir, ".cache", "1fe");
  return {
    projectDir,
    reportsDir,
    srcDir,
    cacheDir,
    distDir: path.join(projectDir, "dist"),
    oneFeConfig: path.resolve(projectDir, ".1fe.config.ts"),
    tsconfig: path.resolve(projectDir, "tsconfig.json"),
    widgetPackageJson: path.resolve(projectDir, "package.json"),
    getWidgetRuntimeConfigJsonPath(outDir) {
      return path.resolve(outDir, "widget-runtime-config.json");
    },
    getLiveVersionCacheJsonPath(environment) {
      return path.resolve(cacheDir, `live-versions-cache-${environment}.json`);
    },
    /**
     * Some of the paths we need to use point to files that
     * do not exist in the file system. Put all such paths here.
     */
    virtual: {
      apiExtractorConfig: path.join(projectDir, "api-extractor.json"),
      variantsEntry: path.resolve(srcDir, "variantsEntry.ts")
    },
    variants: {
      configsGlob: path.resolve(srcDir, "variants", "*", ".1fe.variant.config.ts"),
      getVariantIndex(variantDirName) {
        return path.resolve(srcDir, "variants", variantDirName, "variant.ts");
      }
    },
    scenesEntry: path.resolve(srcDir, path.join("scenes", "index.ts")),
    webpack: {
      analyzerPlugin: {
        statsJson: path.join(reportsDir, "bundle-stats.json"),
        reportHtml: path.join(reportsDir, "bundle-report.html")
      },
      widgetEntry: path.resolve(srcDir, "widget.ts")
    },
    contracts: {
      typesDir: path.resolve(srcDir, "types"),
      widgetTypesDir: path.resolve(srcDir, path.join("types", "widgets")),
      indexDTs: path.resolve(srcDir, path.join("types", "index.d.ts"))
    }
  };
});

// package.json
var engines = {
  node: "22.13.0"};
var package_default = {
  name: "@1fe/cli",
  description: "CLI tools for 1FE development and build infrastructure.",
  version: "0.0.1"};
var preActionHook = async (thisCommand, actionCommand) => {
  const logger = getLogger("[pre-action]");
  const {
    oneFeConfig,
    webpack: { widgetEntry }
  } = getKnownPaths();
  if (!fs.existsSync(oneFeConfig)) {
    logger.error(
      "No 1fe config file found. Please ensure that you are running the CLI from the root of a 1fe project."
    );
    process.exit(1);
  }
  if (!fs.existsSync(widgetEntry)) {
    logger.error(
      `No widget entry file found at ${widgetEntry}. Please ensure that you are running the CLI from the root of a 1fe project.`
    );
    process.exit(1);
  }
  const options = await getPlainOptions();
  logger.log("Starting the CLI with options:", options);
};
async function getPlainOptions() {
  const options = {};
  for (const key in oneFeProgram.opts()) {
    options[key] = await oneFeProgram.getOptionValue(key);
  }
  return options;
}

// src/lib/config/parseEnv.ts
async function parseEnv(envValue) {
  const { baseConfig } = await getConfig();
  if (!baseConfig.environments[envValue]) {
    throw new Error(
      `No base configuration found for environment "${envValue}". Are you sure you have the correct --environment ?`
    );
  }
  return envValue;
}

// src/oneFeProgram/oneFeProgram.ts
var oneFeProgram = new extraTypings.Command().name(package_default.name).description(package_default.description).version(package_default.version).hook("preAction", preActionHook).hook("postAction", async () => {
  console.log("post action hook executed");
}).addOption(
  new extraTypings.Option(
    "--environment <environment>",
    "Environment to build for. This should match one of the environments defined in your .1fe.config.ts"
  ).argParser(parseEnv).makeOptionMandatory()
).addOption(
  new extraTypings.Option(
    "--trace",
    "log extra information to the terminal for beter insight into what the CLI is doing."
  ).default(false)
).addOption(
  new extraTypings.Option(
    "--debug",
    "Enables --trace by default and logs options and parameters in various processes to the terminal for debugging"
  ).default(false)
).option(
  "--ci",
  "Run in CI mode. Follows process.env.CI.",
  !!process.env.CI || false
).option(
  "-q, --quiet",
  "Disable the 1FE Help Bot animation at the start of a command",
  false
);
function getLogger(prefix) {
  const debug = oneFeProgram.getOptionValue("debug");
  const trace = oneFeProgram.getOptionValue("trace");
  const coloredPrefix = chalk4__default.default.gray(prefix);
  const logger = {
    /** General purpose log. Shows up always */
    log: (...args) => console.log(`${coloredPrefix}`, ...args),
    /** Debug log. Shows up only when --debug is used */
    debug: (...args) => console.debug(`${coloredPrefix}`, ...colorStrings("cyan")(...args)),
    /** Info log. Shows up only when --trace is used */
    info: (...args) => console.log(`${coloredPrefix}`, ...colorStrings("gray")(...args)),
    /** Warning log. Shows up only when --trace is used */
    warn: (...args) => console.warn(`${coloredPrefix}`, ...colorStrings("yellow")(...args)),
    /** Error log. Shows up always */
    error: (...args) => console.error(`${coloredPrefix}`, ...colorStrings("red")(...args))
  };
  if (!trace) {
    logger.info = () => {
    };
    logger.warn = () => {
    };
  }
  if (!debug) {
    logger.debug = () => {
    };
  }
  return logger;
}
function colorStrings(color) {
  return (...args) => args.map((arg) => typeof arg === "string" ? chalk4__default.default[color](arg) : arg);
}
var managedSchema = zod.z.union([
  zod.z.object({
    id: zod.z.string(),
    version: zod.z.string(),
    type: zod.z.literal("installed")
  }),
  zod.z.object({
    id: zod.z.string(),
    version: zod.z.string(),
    type: zod.z.literal("external"),
    name: zod.z.string(),
    isPreloaded: zod.z.literal(true),
    path: zod.z.string()
  })
]);
var authSchema = zod.z.object({
  authenticationType: zod.z.string()
});
var importMapOverridesSchema = zod.z.object({
  enableUI: zod.z.boolean().optional(),
  allowedSources: zod.z.array(zod.z.string()).optional()
});
var devtoolsSchema = zod.z.object({
  importMapOverrides: importMapOverridesSchema.optional()
});
var librariesSchema = zod.z.object({
  basePrefix: zod.z.string(),
  managed: zod.z.array(managedSchema)
});
var pluginSchema = zod.z.object({
  enabled: zod.z.boolean(),
  route: zod.z.string(),
  auth: authSchema.optional()
});
var releaseConfigSchema = zod.z.object({
  widgetId: zod.z.string(),
  type: zod.z.string().optional(),
  plugin: pluginSchema,
  version: zod.z.string()
});
var widgetsSchema = zod.z.object({
  basePrefix: zod.z.string(),
  releaseConfig: zod.z.array(releaseConfigSchema)
});
var cdnSchema = zod.z.object({
  libraries: librariesSchema,
  widgets: widgetsSchema
});
var commonConfigSchema = zod.z.object({
  cdn: cdnSchema,
  devtools: devtoolsSchema.optional(),
  browserslistConfig: zod.z.array(zod.z.string())
});

// src/lib/config/configSchema.ts
var preloadSchema = zod.z.union([
  zod.z.object({ apiGet: zod.z.string() }),
  zod.z.object({ widget: zod.z.string() }),
  zod.z.object({ html: zod.z.string() })
]).array();
var pinnedWidgetSchema = zod.z.object({
  widgetId: zod.z.string(),
  version: zod.z.string()
});
var widgetSchema = zod.z.object({
  widgetId: zod.z.string()
});
var environmentNameSchema = zod.z.string();
var dependsOnSchema = zod.z.object({
  pinnedWidgets: pinnedWidgetSchema.array().optional(),
  widgets: widgetSchema.array().optional()
});
var runtimeConfigSchema = zod.z.object({
  dependsOn: dependsOnSchema.optional(),
  // TODO - add a validation here to ensure that a widget of a version exists over here.
  preload: preloadSchema.optional()
  // TODO - add a validation here to ensure that a widget of a version exists over here.
});
var runtimeConfigRecordSchema = zod.z.record(environmentNameSchema, runtimeConfigSchema).optional();
var environmentSchema = zod.z.object({
  commonConfig: commonConfigSchema,
  shellBaseUrl: zod.z.string().url(),
  serverBaseUrl: zod.z.string().url()
});
var baseConfigObjectSchema = zod.z.object({
  environments: zod.z.record(environmentNameSchema, environmentSchema),
  bathtubUrl: zod.z.string().url().optional()
});
var baseConfigSchema = zod.z.union([
  baseConfigObjectSchema,
  // this is when base config is defined in the project
  zod.z.string().url(),
  // this is when base config is fetched from a URL
  zod.z.function().returns(zod.z.promise(baseConfigObjectSchema))
  // This is when base config is shared as a npm package
]);
var onefeConfigurationSchema = zod.z.object({
  /**
   * Part of the configuration that should be externalized and distributed
   */
  baseConfig: baseConfigSchema,
  /**
   * Runtime configuration for the application, per Environment.
   */
  runtimeConfig: runtimeConfigRecordSchema.optional(),
  /**
   * Webpack configs overrides per environment.
   */
  webpackConfigs: zod.z.record(environmentNameSchema, zod.z.custom()).optional()
});

// src/lib/config/validateConfig.ts
async function validateConfig(config) {
  const logger = getLogger("[config][validate]");
  logger.debug(
    "Validating configuration\n\n",
    JSON.stringify(config, null, 2),
    "\n"
  );
  try {
    onefeConfigurationSchema.parse(config);
  } catch (error) {
    logger.error(
      "Error validating your configuration:",
      zodValidationError.fromError(error).toString()
    );
    process.exit(1);
  }
  return config;
}

// src/lib/loadTs.ts
async function loadTsDefault(...args) {
  return (await import('ts-import')).load(...args).then((m) => m.default);
}
var getConfig = lodash.memoize(
  async () => {
    const logger = getLogger("[config][get]");
    try {
      const config = await loadTsDefault(
        getKnownPaths().oneFeConfig,
        {
          useCache: false
        }
      );
      if (typeof config.baseConfig === "string") {
        config.baseConfig = await ky__default.default.get(config.baseConfig).json();
      } else if (typeof config.baseConfig === "function") {
        config.baseConfig = await config.baseConfig();
      }
      return validateConfig(config);
    } catch (error) {
      logger.error("Error loading config file:", error);
      process.exit(1);
    }
  }
);

// src/lib/config/getCommonConfigs.ts
var getCommonConfigs = lodash.memoize(async (environment) => {
  const { baseConfig } = await getConfig();
  if (!baseConfig.environments[environment]) {
    throw new Error(
      `No base configuration found for environment "${environment}"`
    );
  }
  return baseConfig.environments[environment].commonConfig;
});

// src/configs/webpack/layers/externalsLayer.ts
async function getExternalsLayer(environment) {
  const logger = getLogger("[webpack][externals]");
  const commonConfig = await getCommonConfigs(environment);
  const externals = commonConfig.cdn.libraries.managed.filter((lib) => lib.type === "external").map((lib) => ({
    [lib.id]: lib.name
  })).reduce((acc, curr) => ({ ...acc, ...curr }), {});
  externals["@1fe/shell"] = "1feContext";
  logger.debug("Using externals:", externals);
  return {
    externals
  };
}
function getPluginsLayer({
  enableAnalyzer,
  enableDevServer,
  isCI
}) {
  const analyzerPlugin = isCI || enableAnalyzer ? getBundleAnalyzerPlugin() : void 0;
  const reactRefreshPlugin = enableDevServer ? new ReactRefreshPlugin__default.default() : void 0;
  return {
    plugins: [
      analyzerPlugin,
      reactRefreshPlugin,
      new webpack.DefinePlugin({
        NODE_ENV: JSON.stringify(process.env.NODE_ENV)
      }),
      new WebpackBar__default.default({
        color: "#4b00fe",
        // Docusign Purple
        fancy: !isCI,
        basic: isCI
      }),
      new SystemJSPublicPathWebpackPlugin__default.default({
        /**
         * If you need the webpack public path to "chop off" some of the directories in the current module's url, you can specify a "root directory level".
         * Note that the root directory level is read from right-to-left, with `1` indicating "current directory" and `2` indicating "up one directory":
         */
        rootDirectoryLevel: 2
      })
    ].filter(Boolean)
  };
}
function getBundleAnalyzerPlugin() {
  return new webpackBundleAnalyzer.BundleAnalyzerPlugin({
    generateStatsFile: true,
    statsFilename: getKnownPaths().webpack.analyzerPlugin.statsJson,
    reportFilename: getKnownPaths().webpack.analyzerPlugin.reportHtml,
    analyzerMode: "static",
    openAnalyzer: false,
    statsOptions: {
      // https://github.com/statoscope/statoscope/tree/master/packages/webpack-plugin#which-stats-flags-statoscope-use
      // Required
      all: false,
      // disable all the stats
      hash: true,
      // compilation hash
      entrypoints: true,
      // entrypoints
      chunks: true,
      // chunks
      chunkModules: true,
      // modules
      reasons: true,
      // modules reasons,
      ids: true,
      // IDs of modules and chunks (webpack 5)
      // nice to have
      nestedModules: true,
      // concatenated modules
      usedExports: true,
      // used exports
      providedExports: true,
      // provided imports
      assets: true,
      // assets
      chunkOrigins: true,
      // chunks origins stats (to find out which modules require a chunk)
      version: true,
      // webpack version
      builtAt: true,
      // build at time
      timings: true,
      // modules timing information
      performance: true,
      // info about oversized assets
      // https://github.com/relative-ci/bundle-stats/tree/master/packages/webpack-plugin#bundlestatswebpackpluginoptions
      modules: true
    }
  });
}

// src/configs/webpack/webpack.constants.ts
var WEBPACK_BUNDLES = {
  MAIN: "1fe-bundle",
  SCENES: "1fe-scenes"
};
var EXTENSIONS = [
  ".json",
  ".ts",
  ".tsx",
  ".js",
  ".jsx",
  ".css",
  ".scss",
  ".sass",
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".webp",
  ".svg"
];

// src/configs/webpack/layers/scenesLayer.ts
var getScenesLayer = lodash.memoize(() => {
  const logger = getLogger("[webpack][scenes]");
  const sceneEntryPath = getKnownPaths().scenesEntry;
  if (fs.existsSync(sceneEntryPath)) {
    logger.info("Scenes entry path exists:", sceneEntryPath);
    return {
      entry: {
        [WEBPACK_BUNDLES.SCENES]: sceneEntryPath
      }
    };
  }
  logger.info("No scenes entry file found at", sceneEntryPath);
  return {};
});
async function getTargetLayer(environment) {
  const logger = getLogger("[webpack][target]");
  const browsersListRules = (await getCommonConfigs(environment)).browserslistConfig.join();
  logger.info("Using browserslist config:", chalk4__default.default.blue(browsersListRules));
  return {
    target: `browserslist:${browsersListRules}`
  };
}
var getWidgetPackageJson = lodash.memoize(async () => {
  return await import(getKnownPaths().widgetPackageJson);
});

// src/configs/webpack/layers/variants/variantsEntry.ts.ejs
var variantsEntry_ts_default = '<%#\nThis file is used to create `variantsEntry.ts` file for any widget that happens to contain `src/variants/*/.1fe.variant.config.ts` files.\nThis is an example of how the compiled file will look like:\n\n```ts\nexport default {\n  __hasVariants: true,\n  __variants: [\n    \'variant1\',\n    \'variant2\',\n  ],\n  __getWidget: () => {\n    return import(/* webpackChunkName: "1fe-variants/default" */ "./widget");\n  },\n  __getVariant: (variantId: string) => {\n    switch(variantId) {\n      case \'variant1\': return import(/* webpackChunkName: "1fe-variants/variant1" */ \'./variants/variant1/variant.ts\');\n      case \'variant2\': return import(/* webpackChunkName: "1fe-variants/variant2" */ \'./variants/variant2/variant.ts\');\n    }\n    throw Error(`[1fe][shell] Requested variant "${variantId}" not found on widget "@scope/myWidgetName"`)\n  },\n}\n```\n%>\nexport default {\n  <%# Whether this widget has variants: always `true` for this file. %>\n  __hasVariants: true,\n\n  <%# List of all variant IDs %>\n  __variants: [\n  <% configs.forEach(function (config) { %>\n    \'<%= config.variantId %>\',\n  <% }) %>\n  ],\n\n  <%# Function that returns the widget %>\n  __getWidget: () => {\n    return import(/* webpackChunkName: "1fe-variants/default" */ "./widget");\n  },\n\n  <%# Function that returns the variant %>\n  __getVariant: (variantId: string) => {\n    switch(variantId) {\n<% configs.forEach(function (config) { %>\n      case \'<%= config.variantId %>\': return import(/* webpackChunkName: "1fe-variants/<%= config.variantId %>" */ \'<%= config.variantIndexFilePathNoExtension %>\')\n<% }) %>\n    }\n    throw Error(`[1fe][shell] Requested variant "${variantId}" not found on widget "<%= widgetId %>"`)\n  },\n}\n';
function getFileNameWithoutExtension(filePath) {
  return path.basename(filePath, path.extname(filePath));
}
function getParentDirectoryName(filePath) {
  return path.basename(path.dirname(filePath));
}

// src/configs/webpack/layers/variants/variantsLayer.ts
async function getVariantsEntryLayer() {
  const logger = getLogger("[webpack][variants]");
  const configFiles = globby.sync(getKnownPaths().variants.configsGlob);
  if (!configFiles.length) {
    logger.info("No variant configs found");
    return {};
  }
  const widgetPackageJson = await getWidgetPackageJson();
  const configs = [];
  for (const configFile of configFiles) {
    logger.info(`Found variant config: ${configFile}`);
    try {
      const variantConfig = await loadTsDefault(configFile);
      logger.info(`Loaded variant config for ${variantConfig.variantId}`);
      const variantDirName = getParentDirectoryName(configFile);
      configs.push({
        ...variantConfig,
        variantIndexFilePathNoExtension: getFileNameWithoutExtension(
          getKnownPaths().variants.getVariantIndex(variantDirName)
        )
      });
    } catch (e) {
      logger.error(`Failed to load variant config: ${configFile}`, e);
      process.exit(1);
    }
  }
  try {
    const variantsEntryFileContent = ejs__default.default.render(variantsEntry_ts_default, {
      configs,
      widgetId: widgetPackageJson.name
    });
    const virtualModulePlugin = new VirtualModulesPlugin__default.default({
      [getKnownPaths().virtual.variantsEntry]: variantsEntryFileContent
    });
    return {
      plugins: [virtualModulePlugin],
      entry: {
        [WEBPACK_BUNDLES.MAIN]: [getKnownPaths().virtual.variantsEntry]
      }
    };
  } catch (e) {
    logger.error(
      `Failed to render variant entry for widget "${widgetPackageJson.name}"`,
      e
    );
    process.exit(1);
  }
}
var devServerDefaults = {
  hot: true,
  // enable HMR on the server
  open: false,
  host: "127.0.0.1",
  historyApiFallback: true,
  // fixes error 404-ish errors when using react router :see this SO question: https://stackoverflow.com/questions/43209666/react-router-v4-cannot-get-url
  allowedHosts: "all",
  // permissive headers for using local build in remote 1ds shell
  headers: {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "*",
    "Access-Control-Allow-Headers": "*"
  }
};
function getDevServerLayer({
  enableDevServer,
  devServerOverrides
}) {
  if (!enableDevServer) return {};
  const logger = getLogger("[webpack][devServer]");
  logger.debug("Enabling dev server with overrides:", devServerOverrides);
  return {
    devServer: lodash.merge(devServerDefaults, devServerOverrides)
  };
}

// src/configs/webpack/layers/getDevtoolLayer.ts
function getDevtoolLayer({
  isProduction,
  enableDevServer
}) {
  if (isProduction) {
    return {
      devtool: false
    };
  } else if (enableDevServer) {
    return {
      devtool: "cheap-module-source-map"
    };
  } else {
    return {
      devtool: "source-map"
    };
  }
}

// src/configs/webpack/webpack.config.ts
var merge2 = webpackMerge.mergeWithRules({
  plugins: "prepend",
  output: "replace",
  externals: "append"
});
async function getWebpackConfig({
  mode,
  transpileOnly,
  environment,
  enableAnalyzer = false,
  isCI = false,
  overrides = {},
  enableDevServer = false
}) {
  const isProduction = mode === "production";
  const isDevelopment = mode === "development";
  const {
    devServer: devServerOverrides,
    entry,
    output,
    ...allowedOverrides
  } = overrides;
  return merge2(
    {
      entry: {
        [WEBPACK_BUNDLES.MAIN]: getKnownPaths().webpack.widgetEntry
      }
    },
    await getVariantsEntryLayer(),
    getScenesLayer(),
    await getExternalsLayer(environment),
    await getTargetLayer(environment),
    getPluginsLayer({
      enableAnalyzer: isCI || enableAnalyzer,
      enableDevServer,
      isCI
    }),
    getDevServerLayer({
      enableDevServer,
      devServerOverrides
    }),
    getDevtoolLayer({
      enableDevServer,
      isProduction
    }),
    {
      mode,
      devtool: isProduction ? false : "source-map",
      resolve: {
        alias: {
          "@1fe/shell": "1feContext"
        },
        extensions: EXTENSIONS,
        plugins: [
          new tsconfigPathsWebpackPlugin.TsconfigPathsPlugin({
            configFile: getKnownPaths().tsconfig,
            extensions: EXTENSIONS
          })
        ]
      },
      output: {
        filename: "js/[name].js",
        path: getKnownPaths().distDir,
        publicPath: "/",
        clean: true,
        library: {
          type: "system"
        }
      },
      module: {
        rules: [
          {
            test: /\.([cm]?ts|tsx)$/,
            exclude: /node_modules/,
            use: [
              {
                loader: __require.resolve("babel-loader"),
                options: {
                  sourceType: "unambiguous",
                  presets: ["@babel/preset-env"],
                  plugins: isDevelopment ? [__require.resolve("react-refresh/babel")] : []
                }
              },
              {
                loader: __require.resolve("ts-loader"),
                options: {
                  transpileOnly
                }
              }
            ]
          },
          {
            test: /\.(css|scss|sass)$/,
            exclude: /node_modules/,
            use: [
              __require.resolve("style-loader"),
              {
                loader: __require.resolve("css-loader"),
                options: {
                  modules: {
                    localIdentName: isProduction ? "[hash:base64]" : "[path][name]__[local]--[hash:base64:5]"
                  }
                }
              },
              __require.resolve("sass-loader"),
              {
                loader: __require.resolve("postcss-loader"),
                options: {
                  postcssOptions: {
                    plugins: ["autoprefixer"]
                  }
                }
              }
            ]
          },
          {
            test: /\.(jpe?g|png|svg)$/i,
            type: "asset"
          }
        ]
      }
    },
    allowedOverrides
  );
}

// src/lib/network/network.ts
var REQUEST_TIMEOUT = 5e3;
var fetchWithTimeout = async (url, options, retries = 8) => {
  const logger = getLogger("[cli][network]");
  logger.info(
    `[CLI][NETWORK] Calling ${url} with timeout ${REQUEST_TIMEOUT} and retries left ${retries}`
  );
  const controller = new AbortController();
  const id = setTimeout(() => {
    logger.warn("[CLI][NETWORK] Timed out.");
    controller.abort();
  }, REQUEST_TIMEOUT);
  return fetch(url, {
    ...options,
    signal: controller.signal
  }).catch((err) => {
    if (retries > 0) {
      logger.warn(`[CLI][NETWORK] Network error. Retries left: ${retries}`);
      return fetchWithTimeout(url, options, retries - 1);
    }
    logger.error(
      `[CLI][NETWORK] Failed to fetch: ${url} after all retries.`,
      err
    );
    throw err;
  }).finally(() => clearTimeout(id));
};
var getBaseConfigForEnv = lodash.memoize(async (environment) => {
  const { baseConfig } = await getConfig();
  if (!baseConfig.environments[environment]) {
    throw new Error(
      "No base config found for the specified environment: " + environment
    );
  }
  return baseConfig.environments[environment];
});

// src/lib/network/getKnownUris.ts
var getKnownUris = lodash.memoize(async (environment) => {
  const { serverBaseUrl } = await getBaseConfigForEnv(environment);
  const commonConfig = await getCommonConfigs(environment);
  return {
    version: `${serverBaseUrl}/version`,
    getWidgetBaseCdnUrl(widgetId, widgetVersion) {
      return `${commonConfig.cdn.widgets.basePrefix}${widgetId}/${widgetVersion}`;
    }
  };
});
var fetchLiveVersions = lodash.memoize(async (environment) => {
  const logger = getLogger("[cli][version][fetch]");
  const versionUrl = (await getKnownUris(environment)).version;
  try {
    const res = await fetchWithTimeout(versionUrl);
    const liveVersions = await res.json();
    logger.info(
      `Successfully fetched live versions from ${chalk4__default.default.blue(versionUrl)}`
    );
    return liveVersions;
  } catch (error) {
    logger.error(versionUrl, error);
    throw Error("Failed to fetch versions");
  }
});
function parseHeader(contractContent) {
  const frontMatter = lodash.takeWhile(contractContent.split("\n"), isComment);
  for (const line of frontMatter) {
    const sourceMatch = line.match(sourceMatcher);
    if (!sourceMatch) continue;
    const url = sourceMatch[1];
    const cdnUrlMatch = url.match(cdnUrlMatcher);
    if (cdnUrlMatch) {
      const variantId = cdnUrlMatch[4].replace(/[cC]ontract/, "");
      return {
        url,
        environment: cdnUrlMatch[1],
        widgetId: cdnUrlMatch[2],
        version: cdnUrlMatch[3],
        variantId
      };
    }
  }
  return;
}
function buildContractFile(cdnUrl, content) {
  const header = buildContractFileHeader(cdnUrl);
  return `${header}

${content}`;
}
function buildContractFileHeader(cdnUrl) {
  return `// Warning: This file is managed by 1ds-cli's 'contracts' command
// Any changes will be overwritten
// source: ${cdnUrl}
// Contracts are linted in their respective projects, and should not be included
// in this project's linting rules.
/* eslint-disable @eslint-community/eslint-comments/no-restricted-disable */
/* eslint-disable @eslint-community/eslint-comments/no-unlimited-disable */
/* eslint-disable */
`;
}
var sourceMatcher = /source: (https:\/\/.*)\s*/;
var cdnUrlMatcher = /https:\/\/(.*)\/widgets\/(.+)\/([\d.-]+)\/types\/(?:contracts\/)?([a-zA-Z0-9-]+)\.rolledUp\.d\.ts/;
function isComment(line) {
  return line.startsWith("//");
}
async function* getFiles(dir) {
  const dirents = await promises.readdir(dir, { withFileTypes: true });
  for (const dirent of dirents) {
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      yield* getFiles(res);
    } else {
      yield res;
    }
  }
}

// src/lib/contracts/files.ts
var FileSystem = class {
  constructor(projectSrcTypesPath) {
    this.projectSrcTypesPath = projectSrcTypesPath;
    this.widgetTypesPath = path.resolve(this.projectSrcTypesPath, "widgets");
    this.widgetGlobalsPath = path.resolve(this.widgetTypesPath, "index.d.ts");
  }
  widgetTypesPath;
  widgetGlobalsPath;
  /**
   * Resolves path to a widget's contract file
   * @param widgetId WidgetId
   * @returns A resolved path
   */
  resolveWidgetContractPath(widgetId) {
    const nameParts = widgetId.split("/").map(lodash.camelCase);
    const directories = lodash.initial(nameParts);
    const name = `${nameParts.at(-1)}.d.ts`;
    return path.resolve(this.widgetTypesPath, ...directories, name);
  }
  /**
   * Resolves path to a widget's contract directory
   *  @param widgetId WidgetId
   * @returns A resolved path
   * @example /path/to/project/src/types/widgets/test/widget
   */
  resolveWidgetContractDirPath(widgetId) {
    return path.resolve(this.widgetTypesPath, ...widgetId.split("/").map(lodash.camelCase));
  }
  async readWidgetContract(widgetId) {
    try {
      const path2 = this.resolveWidgetContractPath(widgetId);
      const content = await fsExtra.readFile(path2, { encoding: "utf-8" });
      const header = parseHeader(content);
      if (!header) {
        return null;
      }
      return {
        path: path2,
        header
      };
    } catch (e) {
      return null;
    }
  }
  async removeWidgetContract(widgetId) {
    const contractPath = this.resolveWidgetContractPath(widgetId);
    const contractDirPath = this.resolveWidgetContractDirPath(widgetId);
    try {
      const removableContractPath = await fsExtra.pathExists(contractPath) ? contractPath : contractDirPath;
      await fsExtra.remove(removableContractPath);
      return true;
    } catch (e) {
    }
    return false;
  }
  /**
   * Iterates all widget files in project
   */
  async *iterateWidgetContracts() {
    for await (const path2 of getFiles(this.widgetTypesPath)) {
      const content = await fsExtra.readFile(path2, { encoding: "utf-8" });
      const header = parseHeader(content);
      if (content && header) {
        yield { path: path2, header };
      }
    }
  }
  /**
   * Creates necessary directories and files for widget contracts if they do not exist
   */
  async ensureWidgetContractsFiles() {
    await fsExtra.ensureFile(this.widgetGlobalsPath);
  }
  /**
   * Reads all widget files in project
   */
  async readWidgetContracts() {
    return await arrayFromAsync(this.iterateWidgetContracts());
  }
};
async function arrayFromAsync(generator) {
  const items = [];
  for await (const item of generator) {
    items.push(item);
  }
  return items;
}
async function updateKnownWidgetsFile(fileSystem) {
  const contracts = await fileSystem.readWidgetContracts();
  const content = generateContractIndexFileContent(contracts);
  return fsExtra.outputFile(fileSystem.widgetGlobalsPath, content, {
    encoding: "utf-8",
    flag: "w"
  });
}
function createFriendlyName(widgetId) {
  const parts = widgetId.split("/").map((part) => lodash.upperFirst(lodash.camelCase(part)));
  const friendlyName = `${parts.join("")}Props`;
  if (/^\d/.test(friendlyName)) {
    return `_${friendlyName}`;
  }
  return friendlyName;
}
function getImportPath(fullPath) {
  const parsed = path__default.default.parse(fullPath);
  const portions = parsed.dir.split(path__default.default.sep);
  const relative = lodash.dropWhile(portions, (p) => p !== "src");
  return path__default.default.posix.join(...relative, `${parsed.name}${parsed.ext}`);
}
function generateContractIndexFileContent(contracts) {
  const createImportLine = ({
    path: path2,
    header: { widgetId, variantId }
  }) => {
    const friendlyName = createFriendlyName(`${widgetId}/${variantId}`);
    const importPath = getImportPath(path2);
    return `import type { HostPropsContract as ${friendlyName} } from '${importPath}';`;
  };
  const createKnownWidgetsMapping = ({
    header: { widgetId, variantId }
  }) => {
    const isVariant = variantId !== "";
    if (!isVariant) {
      return `${" ".repeat(4)}'${widgetId}': ${createFriendlyName(
        widgetId
      )};
`;
    }
  };
  const createKnownVariantsMapping = (contractFiles) => {
    const knownVariants = {};
    contractFiles.forEach(({ header: { widgetId, variantId } }) => {
      const isVariant = variantId !== "";
      if (isVariant) {
        const line = `        '${variantId}': ${createFriendlyName(
          `${widgetId}/${variantId}`
        )};`;
        if (!knownVariants[widgetId]) {
          knownVariants[widgetId] = [line];
        } else {
          knownVariants[widgetId].push(line);
        }
      }
    });
    return Object.keys(knownVariants).map((id) => {
      const variants = knownVariants[id].join("\n");
      return `${" ".repeat(4)}'${id}': {
${variants}
${" ".repeat(4)}};`;
    });
  };
  const createKnownDeclaration = (contracts2) => contracts2.length > 0 ? `declare module '@1fe/shell' {
  interface KnownWidgets {
${contracts2.map(createKnownWidgetsMapping).join("")}  }
  interface KnownVariants {
${createKnownVariantsMapping(contracts2)}
  }
}` : "";
  return `// Warning: This file is managed by the 1ds-cli contracts command
// This is a managed dependency, and excluded from project-specific linting rules
/* eslint-disable @eslint-community/eslint-comments/no-restricted-disable */
/* eslint-disable @eslint-community/eslint-comments/no-unlimited-disable */
/* eslint-disable */
${contracts.map(createImportLine).join("\n")}

${createKnownDeclaration(contracts)}`;
}

// src/lib/contracts/url.ts
var widgetContractPath = "/types/contract.rolledUp.d.ts";
var widgetContractPathWithVariants = "/types/contracts/contract.rolledUp.d.ts";
var getVariantContractPath = (variantId) => `/types/contracts/${variantId}Contract.rolledUp.d.ts`;
var getWidgetContractCdnUrl = async (baseUrlArgs) => {
  const baseUrl = (await getKnownUris(baseUrlArgs.environment)).getWidgetBaseCdnUrl(baseUrlArgs.widgetId, baseUrlArgs.version);
  const variantIds = [];
  const variantContractUrls = variantIds.reduce(
    (acc, id) => {
      acc[id] = `${baseUrl}${getVariantContractPath(id)}`;
      return acc;
    },
    {}
  );
  return {
    defaultUrl: `${baseUrl}${widgetContractPath}`,
    defaultUrlInVariantFolder: `${baseUrl}${widgetContractPathWithVariants}`,
    ...variantContractUrls
  };
};

// src/lib/contracts/add.ts
async function addOrUpgradeContract(widgetId, environment, version) {
  const projectSrcTypesPath = getKnownPaths().contracts.typesDir;
  if (!version) {
    return [
      {
        type: "WidgetNotFoundResult",
        widgetId
      }
    ];
  }
  const fileSystem = new FileSystem(projectSrcTypesPath);
  const existingContract = await fileSystem.readWidgetContract(widgetId);
  const existingVersion = existingContract?.header.version;
  const isOutOfDate = existingVersion !== version;
  if (!isOutOfDate) {
    return [
      {
        type: "WidgetContractUpToDate",
        widgetId,
        version
      }
    ];
  }
  const urls = await getWidgetContractCdnUrl({
    environment,
    widgetId,
    version
  });
  const { defaultUrl, defaultUrlInVariantFolder, ...variantUrls } = urls;
  const variantIds = Object.keys(variantUrls);
  const handleCdnResponseAndCreateFile = async (response, widgetIdWithVariant) => {
    if (response.status !== 200) {
      return {
        type: "WidgetContractNotFoundResult",
        widgetId: widgetIdWithVariant,
        expectedUrl: response.url
      };
    }
    const contract = await response.text();
    const writePath = fileSystem.resolveWidgetContractPath(widgetIdWithVariant);
    const contractFileContent = buildContractFile(
      decodeURIComponent(response.url),
      contract
    );
    fsExtra.outputFileSync(writePath, contractFileContent, {
      encoding: "utf-8",
      flag: "w"
    });
    return {
      type: "WidgetContractUpdated",
      widgetId: widgetIdWithVariant,
      version
    };
  };
  const installContract = async (urlOrUrls, widgetIdWithVariant) => {
    const urls2 = urlOrUrls instanceof Array ? urlOrUrls : [urlOrUrls];
    const responses = urls2.map((url) => fetchWithTimeout(decodeURI(url)));
    for await (const response of responses) {
      if (response.status === 200) {
        return handleCdnResponseAndCreateFile(response, widgetIdWithVariant);
      }
    }
    return {
      type: "WidgetContractNotFoundResult",
      widgetId: widgetIdWithVariant,
      expectedUrl: urls2[0]
    };
  };
  const installContractResults = await Promise.all([
    // Fetch the main contract file at whichever location it may be
    installContract([defaultUrl, defaultUrlInVariantFolder], widgetId),
    ...variantIds.map(
      async (variantId) => installContract(urls[variantId], `${widgetId}/${variantId}`)
    )
  ]);
  await updateKnownWidgetsFile(fileSystem);
  return installContractResults;
}

// src/lib/contracts/remove.ts
async function removeContract(widgetId) {
  const projectSrcTypesPath = getKnownPaths().contracts.typesDir;
  const fileSystem = new FileSystem(projectSrcTypesPath);
  const isRemoved = await fileSystem.removeWidgetContract(widgetId);
  if (!isRemoved) {
    return {
      type: "WidgetNotFoundResult",
      widgetId
    };
  }
  await updateKnownWidgetsFile(fileSystem);
  return {
    type: "WidgetContractRemoved",
    widgetId
  };
}

// src/lib/contracts/versions.ts
function findLiveContractVersion(liveVersions, widgetId) {
  const version = liveVersions.configs.widgetConfig.find(
    (wc) => wc.widgetId === widgetId
  )?.version;
  return version;
}

// src/lib/contracts/install.ts
async function getCurrentWidgetContracts(liveVersions) {
  const logger = getLogger("[cli][contracts][get]");
  const projectSrcTypesPath = getKnownPaths().contracts.typesDir;
  const { runtimeConfig } = await getConfig();
  const widgetIdsToAdd = {};
  for (const environment in runtimeConfig) {
    const pinnedWidgets = runtimeConfig[environment]?.dependsOn?.pinnedWidgets || [];
    const widgets = runtimeConfig[environment]?.dependsOn?.widgets || [];
    widgets.forEach(
      (widget) => widgetIdsToAdd[widget.widgetId] = findLiveContractVersion(
        liveVersions,
        widget.widgetId
      )
    );
    pinnedWidgets.forEach(
      (pinnedWidget) => widgetIdsToAdd[pinnedWidget.widgetId] = pinnedWidget.version
    );
  }
  const fileSystem = new FileSystem(projectSrcTypesPath);
  await fileSystem.ensureWidgetContractsFiles();
  const installedWidgetContracts = await fileSystem.readWidgetContracts();
  const contractsToActOn = installedWidgetContracts.reduce(
    (accumulator, dependency) => {
      const {
        version: installedVersion,
        widgetId,
        variantId
      } = dependency.header;
      if (variantId) {
        return accumulator;
      }
      if (!widgetIdsToAdd[widgetId]) {
        return [...accumulator, { widgetId, availableVersion: null }];
      }
      const availableVersion = widgetIdsToAdd[widgetId];
      delete widgetIdsToAdd[widgetId];
      return [...accumulator, { widgetId, availableVersion, installedVersion }];
    },
    []
  );
  Object.keys(widgetIdsToAdd).forEach((widgetId) => {
    contractsToActOn.push({
      widgetId,
      availableVersion: widgetIdsToAdd[widgetId]
    });
  });
  logger.debug("Acting on these contracts - ", contractsToActOn);
  return contractsToActOn;
}
var displayContractErrors = (invalidContracts, stdout) => {
  const spacer = `${os.EOL}${os.EOL}`;
  const introMessage = chalk4__default.default.bold.redBright(
    `Contract Validation Failed!${spacer}`
  );
  const invalidTemplate = invalidContracts.length > 0 ? `${chalk4__default.default.bold.redBright(
    "Missing Contracts:"
  )}${spacer}${invalidContracts.join(os.EOL)}${spacer}` : ``;
  const tscTemplate = stdout ? `${chalk4__default.default.bold.redBright("TypeScript Errors:")}${spacer}${stdout}${spacer}` : ``;
  const instructions = chalk4__default.default.bold.redBright(
    `Please fix the above issues and try again.`
  );
  const template = `${introMessage}${invalidTemplate}${tscTemplate}${instructions}`;
  console.log(template);
};

// src/lib/contracts/misc.ts
function throwIfActionResultNotHandled(x) {
  throw new Error(`Unknown value ${x}`);
}
async function handleInstallActionResults(reportsOfActionTaken, environment, outdated) {
  const logger = getLogger("[cli][contracts]");
  const conflicts = [];
  const upToDate = [];
  for await (const result of reportsOfActionTaken) {
    switch (result.type) {
      case "WidgetContractNotFoundResult": {
        const message = `Published contract not available for latest published version of ${result.widgetId}: (${result.expectedUrl})`;
        logger.warn(message);
        break;
      }
      case "WidgetNotFoundResult": {
        const message = `Widget ${result.widgetId} not found in published versions (${environment})`;
        if (outdated) {
          conflicts.push(message);
        } else {
          logger.warn(message);
        }
        break;
      }
      case "WidgetContractUpToDate": {
        upToDate.push(`${result.widgetId} - ${result.version}`);
        logger.info(
          `Widget ${result.widgetId} is up-to-date ${result.version}`
        );
        break;
      }
      case "WidgetContractUpdated": {
        upToDate.push(`${result.widgetId} - ${result.version}`);
        logger.info(`Widget ${result.widgetId} upgraded to ${result.version}`);
        break;
      }
      case "WidgetContractRemoved": {
        logger.info(`Widget ${result.widgetId} removed`);
        break;
      }
      default:
        throwIfActionResultNotHandled(result);
    }
  }
  if (upToDate.length > 0) {
    logger.info(`Up-to-date widgets: ${upToDate.join(", ")}`);
  }
  return conflicts;
}
var _nodeExec = util.promisify(child_process.exec);
var exit = (code) => {
  const logger = getLogger("[cli]");
  logger.error(`Exiting with code ${code}`);
  return process.exit(code);
};
var exec = async (command, options) => {
  const logger = getLogger("[cli]");
  logger.info(`executing command: ${chalk4__default.default.cyan(command)}`);
  const { stdout } = await _nodeExec(command, options);
  logger.info(`Command stdout: ${chalk4__default.default.cyan(stdout)}`);
  return stdout;
};

// src/commands/contracts/install/contractsInstallAction.ts
async function contractsInstallAction({
  widgetIds = [],
  outdated = false
}) {
  const logger = getLogger("[contracts][install]");
  logger.log("Installing contracts...");
  try {
    const environment = await oneFeProgram.getOptionValue("environment");
    const liveVersions = await fetchLiveVersions(environment);
    const currentWidgetContracts = await getCurrentWidgetContracts(liveVersions);
    const filteredWidgetContracts = currentWidgetContracts.filter(
      ({ widgetId }) => widgetIds?.length === 0 || widgetIds.includes(widgetId)
    );
    const installActionResults = await Promise.all(
      filteredWidgetContracts.map(({ widgetId, availableVersion }) => {
        if (availableVersion === null) {
          return removeContract(widgetId);
        }
        return addOrUpgradeContract(widgetId, environment, availableVersion);
      })
    );
    const invalidContracts = await handleInstallActionResults(
      installActionResults.flat(),
      liveVersions.environment,
      outdated
    );
    const stdout = outdated ? await exec("yarn tsc -p tsconfig.json --noEmit").catch((error) => {
      return error.stdout;
    }) : null;
    if (invalidContracts.length > 0 || stdout) {
      displayContractErrors(invalidContracts, stdout);
      logger.error(`Something went wrong while installing contracts.`);
      exit(1);
    }
  } catch (error) {
    logger.error("Installing Contracts Failed", error);
    exit(1);
  }
}

// src/configs/apiExtractor/apiExtractor.config.ts
var apiExtractorConfig = {
  // TODO - modify this configuration for each variant to generate rolledup contracts
  mainEntryPointFilePath: "<projectFolder>/dist/contract.d.ts",
  bundledPackages: [],
  compiler: {
    tsconfigFilePath: "<projectFolder>/tsconfig.json"
  },
  apiReport: {
    enabled: false,
    reportFileName: "<unscopedPackageName>.api.md",
    reportFolder: "<projectFolder>/api/",
    reportTempFolder: "<projectFolder>/api/temp",
    includeForgottenExports: true
  },
  docModel: {
    enabled: false
  },
  dtsRollup: {
    enabled: true,
    untrimmedFilePath: "<projectFolder>/dist/types/contract.rolledUp.d.ts"
  },
  tsdocMetadata: {
    enabled: false
  },
  messages: {}
};

// src/commands/contracts/generate/contractsGenerateAction.ts
async function contractsGenerateAction() {
  const logger = getLogger("[contracts][generate]");
  const paths = getKnownPaths();
  logger.info("Generating contracts");
  const config = apiExtractor.ExtractorConfig.prepare({
    configObject: {
      ...apiExtractorConfig,
      projectFolder: paths.projectDir
    },
    configObjectFullPath: paths.virtual.apiExtractorConfig,
    packageJsonFullPath: paths.widgetPackageJson
  });
  const extractorResult = apiExtractor.Extractor.invoke(config, {
    localBuild: false,
    // Do not update the API snapshot
    showVerboseMessages: true
  });
  if (extractorResult.succeeded) {
    logger.info("Successfully built contracts");
  } else {
    logger.error("Failed to build contracts");
  }
}

// src/commands/build/buildAction.ts
var buildAction = async (buildOptions) => {
  await buildWebpack(buildOptions);
  await contractsGenerateAction();
};
async function buildWebpack(buildOptions) {
  return new Promise(async (resolve4, reject) => {
    const logger = getLogger("[build]");
    const environment = await oneFeProgram.getOptionValue("environment");
    const { webpackConfigs } = await getConfig();
    const compiler = webpack.webpack(
      await getWebpackConfig({
        mode: buildOptions.mode,
        isCI: oneFeProgram.getOptionValue("ci"),
        environment: buildOptions.liveVersionEnv || environment,
        overrides: webpackConfigs?.[environment],
        enableAnalyzer: buildOptions.analyze
      })
    );
    await contractsInstallAction({
      outdated: false
      // TODO - what should this value be? figure it out.
    });
    compiler.run((error, stats) => {
      if (error || stats?.hasErrors()) {
        logger.error("Webpack errors found in build", {
          error,
          stats: stats?.compilation?.errors
        });
        reject();
      } else {
        logger.log(
          "Webpack build successful!",
          stats?.toString({
            colors: true,
            logging: "none"
          })
        );
        logger.log("\u{1F389} Succesfully built your widget!");
        resolve4();
      }
    });
  });
}

// src/commands/build/buildCommand.ts
var buildCommand = new extraTypings.Command().name("build").description(`build a 1FE widget`).addOption(
  new extraTypings.Option("--mode <mode>", "Build mode").default("production").choices(["development", "production"])
).option(
  "-l, --live-version-env <env>",
  "Which environment to fetch live versions from. The information fetched is used to determine what libraries are externalized from your library and what versions to install locally in your package.json. This should match one of the environments defined in your .1fe.config.ts",
  parseEnv
).option("-a, --analyze-bundle-locally", "Analyze the bundle locally").action(buildAction);
var contractsInstallCommand = new extraTypings.Command("install").addOption(
  new extraTypings.Option(
    "--widgetIds <widgetIds...>",
    "A list of widgets to specifically install contracts of."
  )
).option("--outdated", "Check for outdated contracts", false).description(
  `Install widget contract versions specified in .1ds.config's dependsOn array`
).action(contractsInstallAction);

// src/commands/contracts/contracts-command.ts
var contractsCommand = new extraTypings.Command("contracts").description("Manage widget contracts").addCommand(contractsInstallCommand);
var DEV_START_PORT = 8080;
var DEV_HOST = "127.0.0.1";
async function devCommandAction(devCommandOptions) {
  const { transpileOnly, headless, contractsInstall } = devCommandOptions;
  const logger = getLogger("[dev]");
  logger.debug("starting dev command with options:", devCommandOptions);
  const webpackConfig = await getWebpackConfig({
    transpileOnly,
    mode: "development",
    environment: await oneFeProgram.getOptionValue("environment"),
    enableDevServer: true
  });
  logger.debug("webpack config:", webpackConfig);
  if (contractsInstall) {
    logger.info("Installing contracts...");
    await contractsInstallAction({ outdated: false });
  }
  const port = await getPorts__default.default(DEV_START_PORT, DEV_HOST);
  const server = new WebpackDevServer__default.default(
    {
      ...webpackConfig.devServer,
      port
    },
    webpack.webpack(webpackConfig)
  );
  logger.log(`Starting development server on ${DEV_HOST}:${port}`);
  try {
    await server.start();
    server.compiler.hooks.done.tap("done", async () => {
      const {
        baseConfig: { bathtubUrl }
      } = await getConfig();
      if (bathtubUrl) {
        if (!headless) {
          const bathtubUrlObject = new URL(bathtubUrl);
          bathtubUrlObject.searchParams.set(
            "widgetUrl",
            `http://${DEV_HOST}:${port}/js/1fe-bundle.js`
          );
          logger.log(
            `Opening the widget in the bathtub with the URL: 
	${chalk4__default.default.blue(bathtubUrlObject.href)}
`
          );
          open__default.default(bathtubUrlObject.href);
        } else {
          logger.log("\u{1F480} The browser has been beheaded as instructed.");
        }
      }
    });
  } catch (e) {
    logger.error("Error starting development server:", e);
    process.exit(1);
  }
}

// src/commands/dev/devCommand.ts
var devCommand = new extraTypings.Command("dev").description("dev command for 1fe-cli").addOption(
  new extraTypings.Option(
    "--transpileOnly",
    "Skip type checking in ts-loader. This is only supported in the dev command to help legacy codebases transition to 1DS."
  ).default(false)
).addOption(
  new extraTypings.Option(
    "--overrideRuntimeConfig",
    "Override your widget's integration runtime with your local .1ds.config.ts changes using the runtime_config_overrides query param."
  ).default(false)
).addOption(
  new extraTypings.Option(
    "--headless",
    "Do not open the browser when running the dev command. This is most useful when running multiple widgets locally."
  ).default(false)
).addOption(new extraTypings.Option("--no-contracts-install", "Disable updating contracts")).action(devCommandAction);
async function generateConfigAction({ outDir }) {
  const logger = getLogger("[generate][config]");
  const environment = await oneFeProgram.getOptionValue("environment");
  const oneFeConfig = await getConfig();
  const runtimeConfigPath = getKnownPaths().getWidgetRuntimeConfigJsonPath(outDir);
  try {
    const runtimeEnvironmentConfig = oneFeConfig.runtimeConfig?.[environment] || {};
    fs.writeFileSync(runtimeConfigPath, JSON.stringify(runtimeEnvironmentConfig));
    logger.log(
      `Successfully saved runtime config to disk at ${chalk4__default.default.green(runtimeConfigPath)}`
    );
  } catch (error) {
    logger.error("Failed to generate config", error);
  }
  logger.log("Generating 1fe config file in the current directory.");
}

// src/commands/generate/config/generateConfigCommand.ts
var generateConfigCommand = new extraTypings.Command("config").addOption(
  new extraTypings.Option(
    "-o, --out-dir <path>",
    "output directory"
  ).makeOptionMandatory()
).description(
  "generates a 1fe runtime configuration file in the specified directory."
).action(generateConfigAction);

// src/commands/generate/generateCommand.ts
var generateCommand = new extraTypings.Command("generate").description(
  "A helper command to generate various scaffolding files for your widget."
).addCommand(generateConfigCommand);
var checkNodeVersion = async () => {
  const currentMajorNodeVersion = semver.major(process.version);
  const requiredMajorNodeVersion = semver.major(engines.node);
  if (currentMajorNodeVersion !== requiredMajorNodeVersion) {
    throw new Error(
      `Your detected major node version, ${currentMajorNodeVersion} does not match the major node version used by the 1FE ecosystem, ${requiredMajorNodeVersion}`
    );
  }
};

// src/index.ts
var main = async () => {
  const logger = getLogger("[1fe]");
  try {
    await checkNodeVersion();
    oneFeProgram.addCommand(buildCommand);
    oneFeProgram.addCommand(devCommand);
    oneFeProgram.addCommand(contractsCommand);
    oneFeProgram.addCommand(generateCommand);
    await oneFeProgram.parseAsync(process.argv);
  } catch (error) {
    logger.error("An error occurred running the 1fe cli.", error);
    process.exit(1);
  }
};
if (__require.main === module) {
  main();
}
