(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('child_process'), require('perf_hooks')) :
	typeof define === 'function' && define.amd ? define(['exports', 'child_process', 'perf_hooks'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CliTestingLibrary = {}, global.require$$0, global.perf_hooks));
})(this, (function (exports, require$$0, perf_hooks) { 'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);

	var stripFinalNewline = input => {
	  const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
	  const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();
	  if (input[input.length - 1] === LF) {
	    input = input.slice(0, input.length - 1);
	  }
	  if (input[input.length - 1] === CR) {
	    input = input.slice(0, input.length - 1);
	  }
	  return input;
	};

	// Used for `MutationObserver`. Unsure if it's really needed, but it's worth mentioning that these are not tied to
	// specific CLI instances of `render`. This means that if there are e2e CLI tests that run in parallel, they will
	// execute far more frequently than needed.
	const _observers = new Map();

	// Not perfect as a way to make "MutationObserver" unique IDs, but it should work
	let mutId = 0;
	class MutationObserver {
	  constructor(cb) {
	    this._id = ++mutId;
	    this._cb = cb;
	  }
	  observe() {
	    _observers.set(this._id, this._cb);
	  }
	  disconnect() {
	    _observers.delete(this._id);
	  }
	}
	function _runObservers() {
	  Array.from(_observers.values()).forEach(cb => cb());
	}

	var ansiRegex$1 = function (_temp) {
	  let {
	    onlyFirst = false
	  } = _temp === void 0 ? {} : _temp;
	  const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
	  return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};

	const ansiRegex = ansiRegex$1;
	var stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

	function assertNotNullOrUndefined(matcher) {
	  if (matcher === null || matcher === undefined) {
	    throw new Error(
	    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
	    `It looks like ${matcher} was passed instead of a matcher. Did you do something like getByText(${matcher})?`);
	  }
	}
	function fuzzyMatches(textToMatch, node, matcher, normalizer) {
	  if (typeof textToMatch !== 'string') {
	    return false;
	  }
	  assertNotNullOrUndefined(matcher);
	  const normalizedText = normalizer(textToMatch);
	  if (typeof matcher === 'string' || typeof matcher === 'number') {
	    return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
	  } else if (typeof matcher === 'function') {
	    return matcher(normalizedText, node);
	  } else {
	    return matcher.test(normalizedText);
	  }
	}
	function matches(textToMatch, node, matcher, normalizer) {
	  if (typeof textToMatch !== 'string') {
	    return false;
	  }
	  assertNotNullOrUndefined(matcher);
	  const normalizedText = normalizer(textToMatch);
	  if (matcher instanceof Function) {
	    return matcher(normalizedText, node);
	  } else if (matcher instanceof RegExp) {
	    return matcher.test(normalizedText);
	  } else {
	    return normalizedText === String(matcher);
	  }
	}
	function getDefaultNormalizer(_temp) {
	  let {
	    trim = true,
	    collapseWhitespace = true,
	    stripAnsi: stripAnsi$1 = true
	  } = _temp === void 0 ? {} : _temp;
	  return text => {
	    let normalizedText = text;
	    normalizedText = trim ? normalizedText.trim() : normalizedText;
	    normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, ' ') : normalizedText;
	    normalizedText = stripAnsi$1 ? stripAnsi(normalizedText) : normalizedText;
	    return normalizedText;
	  };
	}

	/**
	 * @param {Object} props
	 * Constructs a normalizer to pass to functions in matches.js
	 * @param {boolean|undefined} props.trim The user-specified value for `trim`, without
	 * any defaulting having been applied
	 * @param {boolean|undefined} props.stripAnsi The user-specified value for `stripAnsi`, without
	 * any defaulting having been applied
	 * @param {boolean|undefined} props.collapseWhitespace The user-specified value for
	 * `collapseWhitespace`, without any defaulting having been applied
	 * @param {Function|undefined} props.normalizer The user-specified normalizer
	 * @returns {Function} A normalizer
	 */

	function makeNormalizer(_ref) {
	  let {
	    trim,
	    stripAnsi,
	    collapseWhitespace,
	    normalizer
	  } = _ref;
	  if (normalizer) {
	    // User has specified a custom normalizer
	    if (typeof trim !== 'undefined' || typeof collapseWhitespace !== 'undefined' || typeof stripAnsi !== 'undefined') {
	      // They've also specified a value for trim or collapseWhitespace
	      throw new Error('trim and collapseWhitespace are not supported with a normalizer. ' + 'If you want to use the default trim and collapseWhitespace logic in your normalizer, ' + 'use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
	    }
	    return normalizer;
	  } else {
	    // No custom normalizer specified. Just use default.
	    return getDefaultNormalizer({
	      trim,
	      collapseWhitespace,
	      stripAnsi
	    });
	  }
	}

	const normalize = getDefaultNormalizer();
	function escapeRegExp(string) {
	  return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
	}
	function getRegExpMatcher(string) {
	  return new RegExp(escapeRegExp(string.toLowerCase()), 'i');
	}
	function makeSuggestion(queryName, element, content, _ref) {
	  let {
	    variant,
	    name
	  } = _ref;
	  const warning = '';
	  const queryOptions = {};
	  const queryArgs = [[].includes(queryName) ? content : getRegExpMatcher(content)];
	  if (name) {
	    queryOptions.name = getRegExpMatcher(name);
	  }
	  if (Object.keys(queryOptions).length > 0) {
	    queryArgs.push(queryOptions);
	  }
	  const queryMethod = `${variant}By${queryName}`;
	  return {
	    queryName,
	    queryMethod,
	    queryArgs,
	    variant,
	    warning,
	    toString() {
	      let [text, options] = queryArgs;
	      text = typeof text === 'string' ? `'${text}'` : text;
	      options = options ? `, { ${Object.entries(options).map(_ref2 => {
        let [k, v] = _ref2;
        return `${k}: ${v}`;
      }).join(', ')} }` : '';
	      return `${queryMethod}(${text}${options})`;
	    }
	  };
	}
	function canSuggest(currentMethod, requestedMethod, data) {
	  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
	}
	function getSuggestedQuery(instance, variant, method) {
	  if (variant === void 0) {
	    variant = 'get';
	  }
	  const textContent = normalize(instance.stdoutArr.map(obj => obj.contents).join('\n'));
	  if (canSuggest('Text', method, textContent)) {
	    return makeSuggestion('Text', instance, textContent, {
	      variant
	    });
	  }
	  return undefined;
	}

	function jestFakeTimersAreEnabled() {
	  /* istanbul ignore else */
	  if (typeof jest !== 'undefined' && jest !== null) {
	    return (
	      // legacy timers
	      setTimeout._isMockFunction === true ||
	      // modern timers
	      // eslint-disable-next-line prefer-object-has-own
	      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
	    );
	  }
	  // istanbul ignore next
	  return false;
	}
	const instanceRef = {
	  current: undefined
	};
	if (typeof afterEach === 'function') {
	  afterEach(() => {
	    instanceRef.current = undefined;
	  });
	}
	function getCurrentInstance() {
	  /**
	   * Worth mentioning that this deviates from the upstream implementation
	   * of `dom-testing-library`'s `getDocument` in waitFor, which throws an error whenever
	   * `window` is not defined.
	   *
	   * Admittedly, this is another way that `cli-testing-library` will need to figure out
	   * the right solution to this problem, since there is no omni-present parent `instance`
	   * in a CLI like there is in a browser. (although FWIW, "process" might work)
	   *
	   * Have ideas how to solve? Please let us know:
	   * https://github.com/crutchcorn/cli-testing-library/issues/
	   */
	  return instanceRef.current;
	}

	// TODO: Does this need to be namespaced for each test that runs?
	//  That way, we don't end up with a "singleton" that ends up wiped between
	//  parallel tests.
	function setCurrentInstance(newInstance) {
	  instanceRef.current = newInstance;
	}
	function debounce(func, timeout) {
	  var _this = this;
	  let timer;
	  return function () {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    clearTimeout(timer);
	    timer = setTimeout(() => {
	      // eslint-disable-next-line no-invalid-this
	      func.apply(_this, args);
	    }, timeout);
	  };
	}

	/**
	 * This is used to bind a series of functions where `instance` is the first argument
	 * to an instance, removing the implicit first argument.
	 */
	function bindObjectFnsToInstance(instance, object) {
	  return Object.entries(object).reduce((prev, _ref) => {
	    let [key, fn] = _ref;
	    prev[key] = function () {
	      for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        props[_key2] = arguments[_key2];
	      }
	      return fn(instance, ...props);
	    };
	    return prev;
	  }, {});
	}

	// import {prettyDOM} from './pretty-dom'

	// It would be cleaner for this to live inside './queries', but
	// other parts of the code assume that all exports from
	// './queries' are query functions.
	let config = {
	  asyncUtilTimeout: 1000,
	  // Short amount of time to wait for your process to spin up after a `spawn`. AFAIK There's unfortunately not much
	  // of a better way to do this
	  renderAwaitTime: 100,
	  // Internal timer time to wait before attempting error recovery debounce action
	  errorDebounceTimeout: 100,
	  unstable_advanceTimersWrapper: cb => cb(),
	  // default value for the `hidden` option in `ByRole` queries
	  // showOriginalStackTrace flag to show the full error stack traces for async errors
	  showOriginalStackTrace: false,
	  // throw errors w/ suggestions for better queries. Opt in so off by default.
	  throwSuggestions: false,
	  // called when getBy* queries fail. (message, container) => Error
	  getInstanceError(message, testInstance) {
	    let instanceWarning = '';
	    if (testInstance) {
	      const stdallArrStr = testInstance.getStdallStr();
	      instanceWarning = `\n${stdallArrStr}`;
	    } else {
	      instanceWarning = '';
	    }
	    const error = new Error([message, instanceWarning].filter(Boolean).join('\n\n'));
	    error.name = 'TestingLibraryElementError';
	    return error;
	  },
	  _disableExpensiveErrorDiagnostics: false
	};
	function runWithExpensiveErrorDiagnosticsDisabled(callback) {
	  try {
	    config._disableExpensiveErrorDiagnostics = true;
	    return callback();
	  } finally {
	    config._disableExpensiveErrorDiagnostics = false;
	  }
	}
	function configure(newConfig) {
	  if (typeof newConfig === 'function') {
	    // Pass the existing config out to the provided function
	    // and accept a delta in return
	    newConfig = newConfig(config);
	  }

	  // Merge the incoming config delta
	  config = {
	    ...config,
	    ...newConfig
	  };
	}
	function getConfig() {
	  return config;
	}

	// Migrated from: https://github.com/testing-library/dom-testing-library/blob/main/src/wait-for.js

	// This is so the stack trace the developer sees is one that's
	// closer to their code (because async stack traces are hard to follow).
	function copyStackTrace(target, source) {
	  target.stack = source.stack.replace(source.message, target.message);
	}
	function waitFor(callback, _ref) {
	  let {
	    instance = getCurrentInstance(),
	    timeout = getConfig().asyncUtilTimeout,
	    showOriginalStackTrace = getConfig().showOriginalStackTrace,
	    stackTraceError,
	    interval = 50,
	    onTimeout = error => {
	      error.message = getConfig().getInstanceError(error.message, instance).message;
	      return error;
	    }
	  } = _ref;
	  if (typeof callback !== 'function') {
	    throw new TypeError('Received `callback` arg must be a function');
	  }
	  return new Promise(async (resolve, reject) => {
	    let lastError, intervalId, observer;
	    let finished = false;
	    let promiseStatus = 'idle';
	    const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
	    const usingJestFakeTimers = jestFakeTimersAreEnabled();
	    if (usingJestFakeTimers) {
	      const {
	        unstable_advanceTimersWrapper: advanceTimersWrapper
	      } = getConfig();
	      checkCallback();
	      // this is a dangerous rule to disable because it could lead to an
	      // infinite loop. However, eslint isn't smart enough to know that we're
	      // setting finished inside `onDone` which will be called when we're done
	      // waiting or when we've timed out.
	      // eslint-disable-next-line no-unmodified-loop-condition
	      while (!finished) {
	        if (!jestFakeTimersAreEnabled()) {
	          const error = new Error(`Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
	          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
	          reject(error);
	          return;
	        }
	        // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's
	        // possible that could make this loop go on forever if someone is using
	        // third party code that's setting up recursive timers so rapidly that
	        // the user's timer's don't get a chance to resolve. So we'll advance
	        // by an interval instead. (We have a test for this case).
	        advanceTimersWrapper(() => {
	          jest.advanceTimersByTime(interval);
	        });

	        // It's really important that checkCallback is run *before* we flush
	        // in-flight promises. To be honest, I'm not sure why, and I can't quite
	        // think of a way to reproduce the problem in a test, but I spent
	        // an entire day banging my head against a wall on this.
	        checkCallback();

	        // In this rare case, we *need* to wait for in-flight promises
	        // to resolve before continuing. We don't need to take advantage
	        // of parallelization so we're fine.
	        // https://stackoverflow.com/a/59243586/971592
	        // eslint-disable-next-line no-await-in-loop
	        await advanceTimersWrapper(async () => {
	          await new Promise(r => {
	            setTimeout(r, 0);
	            jest.advanceTimersByTime(0);
	          });
	        });
	      }
	    } else {
	      intervalId = setInterval(checkRealTimersCallback, interval);
	      observer = new MutationObserver(checkRealTimersCallback);
	      observer.observe();
	      checkCallback();
	    }
	    function onDone(error, result) {
	      finished = true;
	      clearTimeout(overallTimeoutTimer);
	      if (!usingJestFakeTimers) {
	        clearInterval(intervalId);
	        observer.disconnect();
	      }
	      if (error) {
	        reject(error);
	      } else {
	        resolve(result);
	      }
	    }
	    function checkRealTimersCallback() {
	      if (jestFakeTimersAreEnabled()) {
	        const error = new Error(`Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
	        if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
	        return reject(error);
	      } else {
	        return checkCallback();
	      }
	    }
	    function checkCallback() {
	      if (promiseStatus === 'pending') return;
	      try {
	        const result = callback(); // runWithExpensiveErrorDiagnosticsDisabled(callback)
	        if (typeof (result && result.then) === 'function') {
	          promiseStatus = 'pending';
	          result.then(resolvedValue => {
	            promiseStatus = 'resolved';
	            onDone(null, resolvedValue);
	          }, rejectedValue => {
	            promiseStatus = 'rejected';
	            lastError = rejectedValue;
	          });
	        } else {
	          onDone(null, result);
	        }
	        // If `callback` throws, wait for the next mutation, interval, or timeout.
	      } catch (error) {
	        // Save the most recent callback error to reject the promise with it in the event of a timeout
	        lastError = error;
	      }
	    }
	    function handleTimeout() {
	      let error;
	      if (lastError) {
	        error = lastError;
	        if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {
	          copyStackTrace(error, stackTraceError);
	        }
	      } else {
	        error = new Error('Timed out in waitFor.');
	        if (!showOriginalStackTrace) {
	          copyStackTrace(error, stackTraceError);
	        }
	      }
	      onDone(onTimeout(error), null);
	    }
	  });
	}
	function waitForWrapper(callback, options) {
	  // create the error here so its stack trace is as close to the
	  // calling code as possible
	  const stackTraceError = new Error('STACK_TRACE_MESSAGE');
	  return waitFor(callback, {
	    stackTraceError,
	    ...options
	  });
	}

	/*
	eslint
	  max-lines-per-function: ["error", {"max": 200}],
	*/

	function getInstanceError(message, instance) {
	  return getConfig().getInstanceError(message, instance);
	}
	function getSuggestionError(suggestion, container) {
	  return getConfig().getInstanceError(`A better query is available, try this:
${suggestion.toString()}
`, container);
	}

	// this accepts a query function and returns a function which throws an error
	// if an empty list of elements is returned
	function makeGetQuery(queryBy, getMissingError) {
	  return function (instance) {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	    const el = queryBy(instance, ...args);
	    if (!el) {
	      throw getConfig().getInstanceError(getMissingError(instance, ...args), instance);
	    }
	    return el;
	  };
	}

	// this accepts a getter query function and returns a function which calls
	// waitFor and passing a function which invokes the getter.
	function makeFindQuery(getter) {
	  return (container, text, options, waitForOptions) => {
	    return waitForWrapper(() => {
	      return getter(container, text, options);
	    }, {
	      container,
	      ...waitForOptions
	    });
	  };
	}
	const wrapSingleQueryWithSuggestion = (query, queryByName, variant) => function (container) {
	  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    args[_key2 - 1] = arguments[_key2];
	  }
	  const instance = query(container, ...args);
	  const [{
	    suggest = getConfig().throwSuggestions
	  } = {}] = args.slice(-1);
	  if (instance && suggest) {
	    const suggestion = getSuggestedQuery(instance, variant);
	    if (suggestion && !queryByName.endsWith(suggestion.queryName)) {
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	      throw getSuggestionError(suggestion.toString(), container);
	    }
	  }
	  return instance;
	};

	// TODO: This deviates from the published declarations
	// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`
	// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, TestInstance[]>`
	function buildQueries(queryBy, getMissingError) {
	  const getBy = makeGetQuery(queryBy, getMissingError);
	  const queryByWithSuggestions = wrapSingleQueryWithSuggestion(queryBy, queryBy.name, 'get');
	  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'get');
	  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'find'));
	  return [queryByWithSuggestions, getByWithSuggestions, findBy];
	}

	const queryByTextBase = function (instance, text, _temp) {
	  let {
	    exact = false,
	    collapseWhitespace,
	    trim,
	    normalizer,
	    stripAnsi
	  } = _temp === void 0 ? {} : _temp;
	  const matcher = exact ? matches : fuzzyMatches;
	  const matchNormalizer = makeNormalizer({
	    stripAnsi,
	    collapseWhitespace,
	    trim,
	    normalizer
	  });
	  const str = instance.stdoutArr.map(output => output.contents).join('\n');
	  if (matcher(str, instance, text, matchNormalizer)) return instance;else return null;
	};
	const getMissingError$1 = (c, text) => `Unable to find an stdout line with the text: ${text}. This could be because the text is broken up by multiple lines. In this case, you can provide a function for your text matcher to make your matcher more flexible.`;
	const [queryByTextWithSuggestions, getByText, findByText] = buildQueries(queryByTextBase, getMissingError$1);

	const queryByErrorBase = function (instance, text, _temp) {
	  let {
	    exact = false,
	    collapseWhitespace,
	    trim,
	    normalizer,
	    stripAnsi
	  } = _temp === void 0 ? {} : _temp;
	  const matcher = exact ? matches : fuzzyMatches;
	  const matchNormalizer = makeNormalizer({
	    stripAnsi,
	    collapseWhitespace,
	    trim,
	    normalizer
	  });
	  const str = instance.stderrArr.map(obj => obj.contents).join('\n');
	  if (matcher(str, instance, text, matchNormalizer)) return instance;else return null;
	};
	const getMissingError = (c, text) => `Unable to find an stdout line with the text: ${text}. This could be because the text is broken up by multiple lines. In this case, you can provide a function for your text matcher to make your matcher more flexible.`;
	const [queryByErrorWithSuggestions, getByError, findByError] = buildQueries(queryByErrorBase, getMissingError);

	var defaultQueries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		queryByText: queryByTextWithSuggestions,
		getByText: getByText,
		findByText: findByText,
		queryByError: queryByErrorWithSuggestions,
		getByError: getByError,
		findByError: findByError
	});

	/**
	 * @typedef {{[key: string]: Function}} FuncMap
	 */

	/**
	 * @param {TestInstance} instance
	 * @param {FuncMap} queries object of functions
	 * @param {Object} initialValue for reducer
	 * @returns {FuncMap} returns object of functions bound to container
	 */
	function getQueriesForElement(instance, queries, initialValue) {
	  if (queries === void 0) {
	    queries = defaultQueries;
	  }
	  if (initialValue === void 0) {
	    initialValue = {};
	  }
	  return Object.keys(queries).reduce((helpers, key) => {
	    const fn = queries[key];
	    helpers[key] = fn.bind(null, instance);
	    return helpers;
	  }, initialValue);
	}

	var childProcess = require$$0__default["default"];
	var spawn = childProcess.spawn;
	var exec = childProcess.exec;
	var treeKill = function (pid, signal, callback) {
	  if (typeof signal === 'function' && callback === undefined) {
	    callback = signal;
	    signal = undefined;
	  }
	  pid = parseInt(pid);
	  if (Number.isNaN(pid)) {
	    if (callback) {
	      return callback(new Error("pid must be a number"));
	    } else {
	      throw new Error("pid must be a number");
	    }
	  }
	  var tree = {};
	  var pidsToProcess = {};
	  tree[pid] = [];
	  pidsToProcess[pid] = 1;
	  switch (process.platform) {
	    case 'win32':
	      exec('taskkill /pid ' + pid + ' /T /F', callback);
	      break;
	    case 'darwin':
	      buildProcessTree(pid, tree, pidsToProcess, function (parentPid) {
	        return spawn('pgrep', ['-P', parentPid]);
	      }, function () {
	        killAll(tree, signal, callback);
	      });
	      break;
	    // case 'sunos':
	    //     buildProcessTreeSunOS(pid, tree, pidsToProcess, function () {
	    //         killAll(tree, signal, callback);
	    //     });
	    //     break;
	    default:
	      // Linux
	      buildProcessTree(pid, tree, pidsToProcess, function (parentPid) {
	        return spawn('ps', ['-o', 'pid', '--no-headers', '--ppid', parentPid]);
	      }, function () {
	        killAll(tree, signal, callback);
	      });
	      break;
	  }
	};
	function killAll(tree, signal, callback) {
	  var killed = {};
	  try {
	    Object.keys(tree).forEach(function (pid) {
	      tree[pid].forEach(function (pidpid) {
	        if (!killed[pidpid]) {
	          killPid(pidpid, signal);
	          killed[pidpid] = 1;
	        }
	      });
	      if (!killed[pid]) {
	        killPid(pid, signal);
	        killed[pid] = 1;
	      }
	    });
	  } catch (err) {
	    if (callback) {
	      return callback(err);
	    } else {
	      throw err;
	    }
	  }
	  if (callback) {
	    return callback();
	  }
	}
	function killPid(pid, signal) {
	  try {
	    process.kill(parseInt(pid, 10), signal);
	  } catch (err) {
	    if (err.code !== 'ESRCH') throw err;
	  }
	}
	function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
	  var ps = spawnChildProcessesList(parentPid);
	  var allData = '';
	  ps.stdout.on('data', function (data) {
	    var data = data.toString('ascii');
	    allData += data;
	  });
	  var onClose = function (code) {
	    delete pidsToProcess[parentPid];
	    if (code != 0) {
	      // no more parent processes
	      if (Object.keys(pidsToProcess).length == 0) {
	        cb();
	      }
	      return;
	    }
	    allData.match(/\d+/g).forEach(function (pid) {
	      pid = parseInt(pid, 10);
	      tree[parentPid].push(pid);
	      tree[pid] = [];
	      pidsToProcess[pid] = 1;
	      buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
	    });
	  };
	  ps.on('close', onClose);
	}

	const killProc = (instance, signal) => new Promise((resolve, reject) => {
	  if (!instance.process.pid || instance.process.pid && instance.hasExit()) {
	    resolve();
	    return;
	  }
	  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	  treeKill(instance.process.pid, signal, async err => {
	    try {
	      if (err) {
	        if (err.message.includes('The process') && err.message.includes('not found.')) {
	          resolve();
	          return;
	        }
	        if (err.message.includes('could not be terminated') && err.message.includes('There is no running instance of the task.') && instance.hasExit()) {
	          resolve();
	          return;
	        }
	        const isOperationNotSupported = err.message.includes('The operation attempted is not supported.');
	        const isAccessDenied = err.message.includes('Access is denied.');
	        if (err.message.includes('could not be terminated') && (isOperationNotSupported || isAccessDenied)) {
	          const sleep = t => new Promise(r => setTimeout(r, t));
	          await sleep(getConfig().errorDebounceTimeout);
	          if (instance.hasExit()) {
	            resolve();
	            return;
	          }
	          console.warn('Ran into error while trying to kill process:');
	          console.warn(err.toString());
	          console.warn(`This is likely due to Window's permissions.
                Because this error is prevalent on CI Windows systems with the tree-kill package, we are attempting
                 an alternative kill method.`);
	          console.warn();
	          console.warn('Be aware that this alternative kill method is not guaranteed to work with subprocesses, and they may not exit properly as a result.');
	          const didKill = instance.process.kill(signal);
	          if (didKill) {
	            resolve();
	          } else {
	            console.error('Alternative kill method failed. Rejecting with original error.');
	            reject(err);
	          }
	          return;
	        }
	        reject(err);
	      } else resolve();
	    } catch (e) {
	      reject(e);
	    }
	  });
	});

	const isWin = process.platform === 'win32';
	const eventMap = {
	  sigterm: instance => killProc(instance, isWin ? undefined : 'SIGTERM'),
	  sigkill: instance => killProc(instance, isWin ? undefined : 'SIGKILL'),
	  write: (instance, props) => instance.process.stdin.write(props.value)
	};

	/**
	 * Silence TypeScript errors
	 * @type {*}
	 */
	const fireEvent = function (instance, event, props) {
	  if (props === void 0) {
	    props = undefined;
	  }
	  eventMap[event](instance, props);
	};
	Object.entries(eventMap).forEach(_ref => {
	  let [eventName, eventFn] = _ref;
	  fireEvent[eventName] = function (instance) {
	    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      props[_key - 1] = arguments[_key];
	    }
	    eventFn(instance, ...props);
	  };
	});

	function wait(time) {
	  return new Promise(resolve => setTimeout(() => resolve(), time));
	}

	var bracketDict = /*#__PURE__*/function (bracketDict) {
	  bracketDict["["] = "]";
	  return bracketDict;
	}(bracketDict || {});
	/**
	 * Get the next key from keyMap
	 *
	 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
	 * Everything else will be interpreted as a typed character - e.g. `a`.
	 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
	 */
	function getNextKeyDef(text, options) {
	  const {
	    type,
	    descriptor,
	    consumedLength
	  } = readNextDescriptor(text);
	  const keyDef = options.keyboardMap.find(def => {
	    if (type === '[') {
	      return def.code?.toLowerCase() === descriptor.toLowerCase();
	    }
	    return def.hex === descriptor;
	  }) ?? {
	    code: descriptor,
	    hex: 'Unknown'
	  };
	  return {
	    keyDef,
	    consumedLength
	  };
	}
	function readNextDescriptor(text) {
	  let pos = 0;
	  const startBracket = text[pos] in bracketDict ? text[pos] : '';
	  pos += startBracket.length;

	  // `foo[[bar` is an escaped char at position 3,
	  // but `foo[[[>5}bar` should be treated as `{` pressed down for 5 keydowns.
	  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\${startBracket}+`))[0].length : 0;
	  const isEscapedChar = startBracketRepeated === 2;
	  const type = isEscapedChar ? '' : startBracket;
	  return {
	    type,
	    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))
	  };
	}
	function readPrintableChar(text, pos) {
	  const descriptor = text[pos];
	  assertDescriptor(descriptor, text, pos);
	  pos += descriptor.length;
	  return {
	    consumedLength: pos,
	    descriptor,
	    releasePrevious: false,
	    releaseSelf: true,
	    repeat: 1
	  };
	}
	function readTag(text, pos, startBracket) {
	  const descriptor = text.slice(pos).match(/^\w+/)?.[0];
	  assertDescriptor(descriptor, text, pos);
	  pos += descriptor.length;
	  const expectedEndBracket = bracketDict[startBracket];
	  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
	  if (!endBracket) {
	    throw new Error(getErrorMessage(`"${expectedEndBracket}"`, text[pos], text));
	  }
	  pos += endBracket.length;
	  return {
	    consumedLength: pos,
	    descriptor
	  };
	}
	function assertDescriptor(descriptor, text, pos) {
	  if (!descriptor) {
	    throw new Error(getErrorMessage('key descriptor', text[pos], text));
	  }
	}
	function getErrorMessage(expected, found, text) {
	  return `Expected ${expected} but found "${found ?? ''}" in "${text}"
    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options
    for more information about how userEvent parses your input.`;
	}

	async function keyboardImplementation(instance, text, options) {
	  const {
	    keyDef,
	    consumedLength
	  } = getNextKeyDef(text, options);
	  keypress(keyDef, instance);
	  if (text.length > consumedLength) {
	    if (options.delay > 0) {
	      await wait(options.delay);
	    }
	    return keyboardImplementation(instance, text.slice(consumedLength), options);
	  }
	  return void undefined;
	}
	function keypress(keyDef, instance) {
	  fireEvent.write(instance, {
	    value: keyDef.hex
	  });
	}

	/**
	 * Mapping for a default US-104-QWERTY keyboard
	 *
	 * These use ANSI-C quoting, which seems to work for Linux, macOS, and Windows alike
	 * @see https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#ANSI_002dC-Quoting
	 * @see https://stackoverflow.com/questions/35429671/detecting-key-press-within-bash-scripts
	 * @see https://gist.github.com/crutchcorn/2811db78a7b924cf54f4507198427fd2
	 */
	const defaultKeyMap = [
	// alphanumeric keys
	{
	  code: 'Digit!',
	  hex: '\x21'
	}, {
	  code: 'Digit#',
	  hex: '\x23'
	}, {
	  code: 'Digit$',
	  hex: '\x24'
	}, {
	  code: 'Digit%',
	  hex: '\x25'
	}, {
	  code: 'Digit&',
	  hex: '\x26'
	}, {
	  code: 'Digit(',
	  hex: '\x29'
	}, {
	  code: 'Digit)',
	  hex: '\x29'
	}, {
	  code: 'Digit*',
	  hex: '\x2a'
	}, {
	  code: 'Digit-',
	  hex: '\x2d'
	}, {
	  code: 'Digit@',
	  hex: '\x40'
	}, {
	  code: 'Digit^',
	  hex: '\x5e'
	}, {
	  code: 'Digit{',
	  hex: '\x7b'
	}, {
	  code: 'Digit|',
	  hex: '\x7c'
	}, {
	  code: 'Digit}',
	  hex: '\x7d'
	}, {
	  code: 'Digit~',
	  hex: '\x7e'
	}, {
	  code: 'Digit0',
	  hex: '\x30'
	}, {
	  code: 'Digit1',
	  hex: '\x31'
	}, {
	  code: 'Digit2',
	  hex: '\x32'
	}, {
	  code: 'Digit3',
	  hex: '\x33'
	}, {
	  code: 'Digit4',
	  hex: '\x34'
	}, {
	  code: 'Digit5',
	  hex: '\x35'
	}, {
	  code: 'Digit6',
	  hex: '\x36'
	}, {
	  code: 'Digit7',
	  hex: '\x37'
	}, {
	  code: 'Digit8',
	  hex: '\x38'
	}, {
	  code: 'Digit9',
	  hex: '\x39'
	}, {
	  code: 'KeyA',
	  hex: '\x41'
	}, {
	  code: 'KeyB',
	  hex: '\x42'
	}, {
	  code: 'KeyC',
	  hex: '\x43'
	}, {
	  code: 'KeyD',
	  hex: '\x44'
	}, {
	  code: 'KeyE',
	  hex: '\x45'
	}, {
	  code: 'KeyF',
	  hex: '\x46'
	}, {
	  code: 'KeyG',
	  hex: '\x47'
	}, {
	  code: 'KeyH',
	  hex: '\x48'
	}, {
	  code: 'KeyI',
	  hex: '\x49'
	}, {
	  code: 'KeyJ',
	  hex: '\x4a'
	}, {
	  code: 'KeyK',
	  hex: '\x4b'
	}, {
	  code: 'KeyL',
	  hex: '\x4c'
	}, {
	  code: 'KeyM',
	  hex: '\x4d'
	}, {
	  code: 'KeyN',
	  hex: '\x4e'
	}, {
	  code: 'KeyO',
	  hex: '\x4f'
	}, {
	  code: 'KeyP',
	  hex: '\x50'
	}, {
	  code: 'KeyQ',
	  hex: '\x51'
	}, {
	  code: 'KeyR',
	  hex: '\x52'
	}, {
	  code: 'KeyS',
	  hex: '\x53'
	}, {
	  code: 'KeyT',
	  hex: '\x54'
	}, {
	  code: 'KeyU',
	  hex: '\x55'
	}, {
	  code: 'KeyV',
	  hex: '\x56'
	}, {
	  code: 'KeyW',
	  hex: '\x57'
	}, {
	  code: 'KeyX',
	  hex: '\x58'
	}, {
	  code: 'KeyY',
	  hex: '\x59'
	}, {
	  code: 'KeyZ',
	  hex: '\x5a'
	}, {
	  code: 'Digit_',
	  hex: '\x5f'
	}, {
	  code: 'KeyLowerA',
	  hex: '\x61'
	}, {
	  code: 'KeyLowerB',
	  hex: '\x62'
	}, {
	  code: 'KeyLowerC',
	  hex: '\x63'
	}, {
	  code: 'KeyLowerD',
	  hex: '\x64'
	}, {
	  code: 'KeyLowerE',
	  hex: '\x65'
	}, {
	  code: 'KeyLowerF',
	  hex: '\x66'
	}, {
	  code: 'KeyLowerG',
	  hex: '\x67'
	}, {
	  code: 'KeyLowerH',
	  hex: '\x68'
	}, {
	  code: 'KeyLowerI',
	  hex: '\x69'
	}, {
	  code: 'KeyLowerJ',
	  hex: '\x6a'
	}, {
	  code: 'KeyLowerK',
	  hex: '\x6b'
	}, {
	  code: 'KeyLowerL',
	  hex: '\x6c'
	}, {
	  code: 'KeyLowerM',
	  hex: '\x6d'
	}, {
	  code: 'KeyLowerN',
	  hex: '\x6e'
	}, {
	  code: 'KeyLowerO',
	  hex: '\x6f'
	}, {
	  code: 'KeyLowerP',
	  hex: '\x70'
	}, {
	  code: 'KeyLowerQ',
	  hex: '\x71'
	}, {
	  code: 'KeyLowerR',
	  hex: '\x72'
	}, {
	  code: 'KeyLowerS',
	  hex: '\x73'
	}, {
	  code: 'KeyLowerT',
	  hex: '\x74'
	}, {
	  code: 'KeyLowerU',
	  hex: '\x75'
	}, {
	  code: 'KeyLowerV',
	  hex: '\x76'
	}, {
	  code: 'KeyLowerW',
	  hex: '\x77'
	}, {
	  code: 'KeyLowerX',
	  hex: '\x78'
	}, {
	  code: 'KeyLowerY',
	  hex: '\x79'
	}, {
	  code: 'KeyLowerZ',
	  hex: '\x7a'
	},
	// alphanumeric block - functional
	{
	  code: 'Space',
	  hex: '\x20'
	}, {
	  code: 'Backspace',
	  hex: '\x08'
	}, {
	  code: 'Enter',
	  hex: '\x0D'
	},
	// function
	{
	  code: 'Escape',
	  hex: '\x1b'
	},
	// arrows
	{
	  code: 'ArrowUp',
	  hex: '\x1b\x5b\x41'
	}, {
	  code: 'ArrowDown',
	  hex: '\x1B\x5B\x42'
	}, {
	  code: 'ArrowLeft',
	  hex: '\x1b\x5b\x44'
	}, {
	  code: 'ArrowRight',
	  hex: '\x1b\x5b\x43'
	},
	// control pad
	{
	  code: 'Home',
	  hex: '\x1b\x4f\x48'
	}, {
	  code: 'End',
	  hex: '\x1b\x4f\x46'
	}, {
	  code: 'Delete',
	  hex: '\x1b\x5b\x33\x7e'
	}, {
	  code: 'PageUp',
	  hex: '\x1b\x5b\x35\x7e'
	}, {
	  code: 'PageDown',
	  hex: '\x1b\x5b\x36\x7e'
	}

	// TODO: add mappings
	];

	function keyboard(instance, text, options) {
	  const {
	    promise
	  } = keyboardImplementationWrapper(instance, text, options);
	  if ((options?.delay ?? 0) > 0) {
	    return promise;
	  } else {
	    // prevent users from dealing with UnhandledPromiseRejectionWarning in sync call
	    promise.catch(console.error);
	  }
	}
	function keyboardImplementationWrapper(instance, text, config) {
	  if (config === void 0) {
	    config = {};
	  }
	  const {
	    delay = 0,
	    keyboardMap = defaultKeyMap
	  } = config;
	  const options = {
	    delay,
	    keyboardMap
	  };
	  return {
	    promise: keyboardImplementation(instance, text, options)
	  };
	}

	const userEvent = {
	  keyboard
	};

	var isFullwidthCodePoint$2 = {exports: {}};

	/* eslint-disable yoda */
	const isFullwidthCodePoint$1 = codePoint => {
	  if (Number.isNaN(codePoint)) {
	    return false;
	  }

	  // Code points are derived from:
	  // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	  if (codePoint >= 0x1100 && (codePoint <= 0x115F ||
	  // Hangul Jamo
	  codePoint === 0x2329 ||
	  // LEFT-POINTING ANGLE BRACKET
	  codePoint === 0x232A ||
	  // RIGHT-POINTING ANGLE BRACKET
	  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
	  0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F ||
	  // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
	  0x3250 <= codePoint && codePoint <= 0x4DBF ||
	  // CJK Unified Ideographs .. Yi Radicals
	  0x4E00 <= codePoint && codePoint <= 0xA4C6 ||
	  // Hangul Jamo Extended-A
	  0xA960 <= codePoint && codePoint <= 0xA97C ||
	  // Hangul Syllables
	  0xAC00 <= codePoint && codePoint <= 0xD7A3 ||
	  // CJK Compatibility Ideographs
	  0xF900 <= codePoint && codePoint <= 0xFAFF ||
	  // Vertical Forms
	  0xFE10 <= codePoint && codePoint <= 0xFE19 ||
	  // CJK Compatibility Forms .. Small Form Variants
	  0xFE30 <= codePoint && codePoint <= 0xFE6B ||
	  // Halfwidth and Fullwidth Forms
	  0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 ||
	  // Kana Supplement
	  0x1B000 <= codePoint && codePoint <= 0x1B001 ||
	  // Enclosed Ideographic Supplement
	  0x1F200 <= codePoint && codePoint <= 0x1F251 ||
	  // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
	  0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
	    return true;
	  }
	  return false;
	};
	isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
	isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;

	const regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';
	const astralRegex$1 = options => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');
	var astralRegex_1 = astralRegex$1;

	var ansiStyles$1 = {exports: {}};

	var colorName;
	var hasRequiredColorName;
	function requireColorName() {
	  if (hasRequiredColorName) return colorName;
	  hasRequiredColorName = 1;
	  colorName = {
	    "aliceblue": [240, 248, 255],
	    "antiquewhite": [250, 235, 215],
	    "aqua": [0, 255, 255],
	    "aquamarine": [127, 255, 212],
	    "azure": [240, 255, 255],
	    "beige": [245, 245, 220],
	    "bisque": [255, 228, 196],
	    "black": [0, 0, 0],
	    "blanchedalmond": [255, 235, 205],
	    "blue": [0, 0, 255],
	    "blueviolet": [138, 43, 226],
	    "brown": [165, 42, 42],
	    "burlywood": [222, 184, 135],
	    "cadetblue": [95, 158, 160],
	    "chartreuse": [127, 255, 0],
	    "chocolate": [210, 105, 30],
	    "coral": [255, 127, 80],
	    "cornflowerblue": [100, 149, 237],
	    "cornsilk": [255, 248, 220],
	    "crimson": [220, 20, 60],
	    "cyan": [0, 255, 255],
	    "darkblue": [0, 0, 139],
	    "darkcyan": [0, 139, 139],
	    "darkgoldenrod": [184, 134, 11],
	    "darkgray": [169, 169, 169],
	    "darkgreen": [0, 100, 0],
	    "darkgrey": [169, 169, 169],
	    "darkkhaki": [189, 183, 107],
	    "darkmagenta": [139, 0, 139],
	    "darkolivegreen": [85, 107, 47],
	    "darkorange": [255, 140, 0],
	    "darkorchid": [153, 50, 204],
	    "darkred": [139, 0, 0],
	    "darksalmon": [233, 150, 122],
	    "darkseagreen": [143, 188, 143],
	    "darkslateblue": [72, 61, 139],
	    "darkslategray": [47, 79, 79],
	    "darkslategrey": [47, 79, 79],
	    "darkturquoise": [0, 206, 209],
	    "darkviolet": [148, 0, 211],
	    "deeppink": [255, 20, 147],
	    "deepskyblue": [0, 191, 255],
	    "dimgray": [105, 105, 105],
	    "dimgrey": [105, 105, 105],
	    "dodgerblue": [30, 144, 255],
	    "firebrick": [178, 34, 34],
	    "floralwhite": [255, 250, 240],
	    "forestgreen": [34, 139, 34],
	    "fuchsia": [255, 0, 255],
	    "gainsboro": [220, 220, 220],
	    "ghostwhite": [248, 248, 255],
	    "gold": [255, 215, 0],
	    "goldenrod": [218, 165, 32],
	    "gray": [128, 128, 128],
	    "green": [0, 128, 0],
	    "greenyellow": [173, 255, 47],
	    "grey": [128, 128, 128],
	    "honeydew": [240, 255, 240],
	    "hotpink": [255, 105, 180],
	    "indianred": [205, 92, 92],
	    "indigo": [75, 0, 130],
	    "ivory": [255, 255, 240],
	    "khaki": [240, 230, 140],
	    "lavender": [230, 230, 250],
	    "lavenderblush": [255, 240, 245],
	    "lawngreen": [124, 252, 0],
	    "lemonchiffon": [255, 250, 205],
	    "lightblue": [173, 216, 230],
	    "lightcoral": [240, 128, 128],
	    "lightcyan": [224, 255, 255],
	    "lightgoldenrodyellow": [250, 250, 210],
	    "lightgray": [211, 211, 211],
	    "lightgreen": [144, 238, 144],
	    "lightgrey": [211, 211, 211],
	    "lightpink": [255, 182, 193],
	    "lightsalmon": [255, 160, 122],
	    "lightseagreen": [32, 178, 170],
	    "lightskyblue": [135, 206, 250],
	    "lightslategray": [119, 136, 153],
	    "lightslategrey": [119, 136, 153],
	    "lightsteelblue": [176, 196, 222],
	    "lightyellow": [255, 255, 224],
	    "lime": [0, 255, 0],
	    "limegreen": [50, 205, 50],
	    "linen": [250, 240, 230],
	    "magenta": [255, 0, 255],
	    "maroon": [128, 0, 0],
	    "mediumaquamarine": [102, 205, 170],
	    "mediumblue": [0, 0, 205],
	    "mediumorchid": [186, 85, 211],
	    "mediumpurple": [147, 112, 219],
	    "mediumseagreen": [60, 179, 113],
	    "mediumslateblue": [123, 104, 238],
	    "mediumspringgreen": [0, 250, 154],
	    "mediumturquoise": [72, 209, 204],
	    "mediumvioletred": [199, 21, 133],
	    "midnightblue": [25, 25, 112],
	    "mintcream": [245, 255, 250],
	    "mistyrose": [255, 228, 225],
	    "moccasin": [255, 228, 181],
	    "navajowhite": [255, 222, 173],
	    "navy": [0, 0, 128],
	    "oldlace": [253, 245, 230],
	    "olive": [128, 128, 0],
	    "olivedrab": [107, 142, 35],
	    "orange": [255, 165, 0],
	    "orangered": [255, 69, 0],
	    "orchid": [218, 112, 214],
	    "palegoldenrod": [238, 232, 170],
	    "palegreen": [152, 251, 152],
	    "paleturquoise": [175, 238, 238],
	    "palevioletred": [219, 112, 147],
	    "papayawhip": [255, 239, 213],
	    "peachpuff": [255, 218, 185],
	    "peru": [205, 133, 63],
	    "pink": [255, 192, 203],
	    "plum": [221, 160, 221],
	    "powderblue": [176, 224, 230],
	    "purple": [128, 0, 128],
	    "rebeccapurple": [102, 51, 153],
	    "red": [255, 0, 0],
	    "rosybrown": [188, 143, 143],
	    "royalblue": [65, 105, 225],
	    "saddlebrown": [139, 69, 19],
	    "salmon": [250, 128, 114],
	    "sandybrown": [244, 164, 96],
	    "seagreen": [46, 139, 87],
	    "seashell": [255, 245, 238],
	    "sienna": [160, 82, 45],
	    "silver": [192, 192, 192],
	    "skyblue": [135, 206, 235],
	    "slateblue": [106, 90, 205],
	    "slategray": [112, 128, 144],
	    "slategrey": [112, 128, 144],
	    "snow": [255, 250, 250],
	    "springgreen": [0, 255, 127],
	    "steelblue": [70, 130, 180],
	    "tan": [210, 180, 140],
	    "teal": [0, 128, 128],
	    "thistle": [216, 191, 216],
	    "tomato": [255, 99, 71],
	    "turquoise": [64, 224, 208],
	    "violet": [238, 130, 238],
	    "wheat": [245, 222, 179],
	    "white": [255, 255, 255],
	    "whitesmoke": [245, 245, 245],
	    "yellow": [255, 255, 0],
	    "yellowgreen": [154, 205, 50]
	  };
	  return colorName;
	}

	/* MIT license */
	var conversions;
	var hasRequiredConversions;
	function requireConversions() {
	  if (hasRequiredConversions) return conversions;
	  hasRequiredConversions = 1;
	  /* eslint-disable no-mixed-operators */
	  const cssKeywords = requireColorName();

	  // NOTE: conversions should only return primitive values (i.e. arrays, or
	  //       values that give correct `typeof` results).
	  //       do not use box values types (i.e. Number(), String(), etc.)

	  const reverseKeywords = {};
	  for (const key of Object.keys(cssKeywords)) {
	    reverseKeywords[cssKeywords[key]] = key;
	  }
	  const convert = {
	    rgb: {
	      channels: 3,
	      labels: 'rgb'
	    },
	    hsl: {
	      channels: 3,
	      labels: 'hsl'
	    },
	    hsv: {
	      channels: 3,
	      labels: 'hsv'
	    },
	    hwb: {
	      channels: 3,
	      labels: 'hwb'
	    },
	    cmyk: {
	      channels: 4,
	      labels: 'cmyk'
	    },
	    xyz: {
	      channels: 3,
	      labels: 'xyz'
	    },
	    lab: {
	      channels: 3,
	      labels: 'lab'
	    },
	    lch: {
	      channels: 3,
	      labels: 'lch'
	    },
	    hex: {
	      channels: 1,
	      labels: ['hex']
	    },
	    keyword: {
	      channels: 1,
	      labels: ['keyword']
	    },
	    ansi16: {
	      channels: 1,
	      labels: ['ansi16']
	    },
	    ansi256: {
	      channels: 1,
	      labels: ['ansi256']
	    },
	    hcg: {
	      channels: 3,
	      labels: ['h', 'c', 'g']
	    },
	    apple: {
	      channels: 3,
	      labels: ['r16', 'g16', 'b16']
	    },
	    gray: {
	      channels: 1,
	      labels: ['gray']
	    }
	  };
	  conversions = convert;

	  // Hide .channels and .labels properties
	  for (const model of Object.keys(convert)) {
	    if (!('channels' in convert[model])) {
	      throw new Error('missing channels property: ' + model);
	    }
	    if (!('labels' in convert[model])) {
	      throw new Error('missing channel labels property: ' + model);
	    }
	    if (convert[model].labels.length !== convert[model].channels) {
	      throw new Error('channel and label counts mismatch: ' + model);
	    }
	    const {
	      channels,
	      labels
	    } = convert[model];
	    delete convert[model].channels;
	    delete convert[model].labels;
	    Object.defineProperty(convert[model], 'channels', {
	      value: channels
	    });
	    Object.defineProperty(convert[model], 'labels', {
	      value: labels
	    });
	  }
	  convert.rgb.hsl = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const min = Math.min(r, g, b);
	    const max = Math.max(r, g, b);
	    const delta = max - min;
	    let h;
	    let s;
	    if (max === min) {
	      h = 0;
	    } else if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else if (b === max) {
	      h = 4 + (r - g) / delta;
	    }
	    h = Math.min(h * 60, 360);
	    if (h < 0) {
	      h += 360;
	    }
	    const l = (min + max) / 2;
	    if (max === min) {
	      s = 0;
	    } else if (l <= 0.5) {
	      s = delta / (max + min);
	    } else {
	      s = delta / (2 - max - min);
	    }
	    return [h, s * 100, l * 100];
	  };
	  convert.rgb.hsv = function (rgb) {
	    let rdif;
	    let gdif;
	    let bdif;
	    let h;
	    let s;
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const v = Math.max(r, g, b);
	    const diff = v - Math.min(r, g, b);
	    const diffc = function (c) {
	      return (v - c) / 6 / diff + 1 / 2;
	    };
	    if (diff === 0) {
	      h = 0;
	      s = 0;
	    } else {
	      s = diff / v;
	      rdif = diffc(r);
	      gdif = diffc(g);
	      bdif = diffc(b);
	      if (r === v) {
	        h = bdif - gdif;
	      } else if (g === v) {
	        h = 1 / 3 + rdif - bdif;
	      } else if (b === v) {
	        h = 2 / 3 + gdif - rdif;
	      }
	      if (h < 0) {
	        h += 1;
	      } else if (h > 1) {
	        h -= 1;
	      }
	    }
	    return [h * 360, s * 100, v * 100];
	  };
	  convert.rgb.hwb = function (rgb) {
	    const r = rgb[0];
	    const g = rgb[1];
	    let b = rgb[2];
	    const h = convert.rgb.hsl(rgb)[0];
	    const w = 1 / 255 * Math.min(r, Math.min(g, b));
	    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
	    return [h, w * 100, b * 100];
	  };
	  convert.rgb.cmyk = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const k = Math.min(1 - r, 1 - g, 1 - b);
	    const c = (1 - r - k) / (1 - k) || 0;
	    const m = (1 - g - k) / (1 - k) || 0;
	    const y = (1 - b - k) / (1 - k) || 0;
	    return [c * 100, m * 100, y * 100, k * 100];
	  };
	  function comparativeDistance(x, y) {
	    /*
	    	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	    */
	    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
	  }
	  convert.rgb.keyword = function (rgb) {
	    const reversed = reverseKeywords[rgb];
	    if (reversed) {
	      return reversed;
	    }
	    let currentClosestDistance = Infinity;
	    let currentClosestKeyword;
	    for (const keyword of Object.keys(cssKeywords)) {
	      const value = cssKeywords[keyword];

	      // Compute comparative distance
	      const distance = comparativeDistance(rgb, value);

	      // Check if its less, if so set as closest
	      if (distance < currentClosestDistance) {
	        currentClosestDistance = distance;
	        currentClosestKeyword = keyword;
	      }
	    }
	    return currentClosestKeyword;
	  };
	  convert.keyword.rgb = function (keyword) {
	    return cssKeywords[keyword];
	  };
	  convert.rgb.xyz = function (rgb) {
	    let r = rgb[0] / 255;
	    let g = rgb[1] / 255;
	    let b = rgb[2] / 255;

	    // Assume sRGB
	    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
	    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
	    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
	    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
	    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
	    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
	    return [x * 100, y * 100, z * 100];
	  };
	  convert.rgb.lab = function (rgb) {
	    const xyz = convert.rgb.xyz(rgb);
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.hsl.rgb = function (hsl) {
	    const h = hsl[0] / 360;
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    let t2;
	    let t3;
	    let val;
	    if (s === 0) {
	      val = l * 255;
	      return [val, val, val];
	    }
	    if (l < 0.5) {
	      t2 = l * (1 + s);
	    } else {
	      t2 = l + s - l * s;
	    }
	    const t1 = 2 * l - t2;
	    const rgb = [0, 0, 0];
	    for (let i = 0; i < 3; i++) {
	      t3 = h + 1 / 3 * -(i - 1);
	      if (t3 < 0) {
	        t3++;
	      }
	      if (t3 > 1) {
	        t3--;
	      }
	      if (6 * t3 < 1) {
	        val = t1 + (t2 - t1) * 6 * t3;
	      } else if (2 * t3 < 1) {
	        val = t2;
	      } else if (3 * t3 < 2) {
	        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	      } else {
	        val = t1;
	      }
	      rgb[i] = val * 255;
	    }
	    return rgb;
	  };
	  convert.hsl.hsv = function (hsl) {
	    const h = hsl[0];
	    let s = hsl[1] / 100;
	    let l = hsl[2] / 100;
	    let smin = s;
	    const lmin = Math.max(l, 0.01);
	    l *= 2;
	    s *= l <= 1 ? l : 2 - l;
	    smin *= lmin <= 1 ? lmin : 2 - lmin;
	    const v = (l + s) / 2;
	    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
	    return [h, sv * 100, v * 100];
	  };
	  convert.hsv.rgb = function (hsv) {
	    const h = hsv[0] / 60;
	    const s = hsv[1] / 100;
	    let v = hsv[2] / 100;
	    const hi = Math.floor(h) % 6;
	    const f = h - Math.floor(h);
	    const p = 255 * v * (1 - s);
	    const q = 255 * v * (1 - s * f);
	    const t = 255 * v * (1 - s * (1 - f));
	    v *= 255;
	    switch (hi) {
	      case 0:
	        return [v, t, p];
	      case 1:
	        return [q, v, p];
	      case 2:
	        return [p, v, t];
	      case 3:
	        return [p, q, v];
	      case 4:
	        return [t, p, v];
	      case 5:
	        return [v, p, q];
	    }
	  };
	  convert.hsv.hsl = function (hsv) {
	    const h = hsv[0];
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const vmin = Math.max(v, 0.01);
	    let sl;
	    let l;
	    l = (2 - s) * v;
	    const lmin = (2 - s) * vmin;
	    sl = s * vmin;
	    sl /= lmin <= 1 ? lmin : 2 - lmin;
	    sl = sl || 0;
	    l /= 2;
	    return [h, sl * 100, l * 100];
	  };

	  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	  convert.hwb.rgb = function (hwb) {
	    const h = hwb[0] / 360;
	    let wh = hwb[1] / 100;
	    let bl = hwb[2] / 100;
	    const ratio = wh + bl;
	    let f;

	    // Wh + bl cant be > 1
	    if (ratio > 1) {
	      wh /= ratio;
	      bl /= ratio;
	    }
	    const i = Math.floor(6 * h);
	    const v = 1 - bl;
	    f = 6 * h - i;
	    if ((i & 0x01) !== 0) {
	      f = 1 - f;
	    }
	    const n = wh + f * (v - wh); // Linear interpolation

	    let r;
	    let g;
	    let b;
	    /* eslint-disable max-statements-per-line,no-multi-spaces */
	    switch (i) {
	      default:
	      case 6:
	      case 0:
	        r = v;
	        g = n;
	        b = wh;
	        break;
	      case 1:
	        r = n;
	        g = v;
	        b = wh;
	        break;
	      case 2:
	        r = wh;
	        g = v;
	        b = n;
	        break;
	      case 3:
	        r = wh;
	        g = n;
	        b = v;
	        break;
	      case 4:
	        r = n;
	        g = wh;
	        b = v;
	        break;
	      case 5:
	        r = v;
	        g = wh;
	        b = n;
	        break;
	    }
	    /* eslint-enable max-statements-per-line,no-multi-spaces */

	    return [r * 255, g * 255, b * 255];
	  };
	  convert.cmyk.rgb = function (cmyk) {
	    const c = cmyk[0] / 100;
	    const m = cmyk[1] / 100;
	    const y = cmyk[2] / 100;
	    const k = cmyk[3] / 100;
	    const r = 1 - Math.min(1, c * (1 - k) + k);
	    const g = 1 - Math.min(1, m * (1 - k) + k);
	    const b = 1 - Math.min(1, y * (1 - k) + k);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.rgb = function (xyz) {
	    const x = xyz[0] / 100;
	    const y = xyz[1] / 100;
	    const z = xyz[2] / 100;
	    let r;
	    let g;
	    let b;
	    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
	    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
	    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

	    // Assume sRGB
	    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
	    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
	    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
	    r = Math.min(Math.max(0, r), 1);
	    g = Math.min(Math.max(0, g), 1);
	    b = Math.min(Math.max(0, b), 1);
	    return [r * 255, g * 255, b * 255];
	  };
	  convert.xyz.lab = function (xyz) {
	    let x = xyz[0];
	    let y = xyz[1];
	    let z = xyz[2];
	    x /= 95.047;
	    y /= 100;
	    z /= 108.883;
	    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
	    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
	    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
	    const l = 116 * y - 16;
	    const a = 500 * (x - y);
	    const b = 200 * (y - z);
	    return [l, a, b];
	  };
	  convert.lab.xyz = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let x;
	    let y;
	    let z;
	    y = (l + 16) / 116;
	    x = a / 500 + y;
	    z = y - b / 200;
	    const y2 = y ** 3;
	    const x2 = x ** 3;
	    const z2 = z ** 3;
	    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
	    x *= 95.047;
	    y *= 100;
	    z *= 108.883;
	    return [x, y, z];
	  };
	  convert.lab.lch = function (lab) {
	    const l = lab[0];
	    const a = lab[1];
	    const b = lab[2];
	    let h;
	    const hr = Math.atan2(b, a);
	    h = hr * 360 / 2 / Math.PI;
	    if (h < 0) {
	      h += 360;
	    }
	    const c = Math.sqrt(a * a + b * b);
	    return [l, c, h];
	  };
	  convert.lch.lab = function (lch) {
	    const l = lch[0];
	    const c = lch[1];
	    const h = lch[2];
	    const hr = h / 360 * 2 * Math.PI;
	    const a = c * Math.cos(hr);
	    const b = c * Math.sin(hr);
	    return [l, a, b];
	  };
	  convert.rgb.ansi16 = function (args, saturation) {
	    if (saturation === void 0) {
	      saturation = null;
	    }
	    const [r, g, b] = args;
	    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	    value = Math.round(value / 50);
	    if (value === 0) {
	      return 30;
	    }
	    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
	    if (value === 2) {
	      ansi += 60;
	    }
	    return ansi;
	  };
	  convert.hsv.ansi16 = function (args) {
	    // Optimization here; we already know the value and don't need to get
	    // it converted for us.
	    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	  };
	  convert.rgb.ansi256 = function (args) {
	    const r = args[0];
	    const g = args[1];
	    const b = args[2];

	    // We use the extended greyscale palette here, with the exception of
	    // black and white. normal palette only has 4 greyscale shades.
	    if (r === g && g === b) {
	      if (r < 8) {
	        return 16;
	      }
	      if (r > 248) {
	        return 231;
	      }
	      return Math.round((r - 8) / 247 * 24) + 232;
	    }
	    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
	    return ansi;
	  };
	  convert.ansi16.rgb = function (args) {
	    let color = args % 10;

	    // Handle greyscale
	    if (color === 0 || color === 7) {
	      if (args > 50) {
	        color += 3.5;
	      }
	      color = color / 10.5 * 255;
	      return [color, color, color];
	    }
	    const mult = (~~(args > 50) + 1) * 0.5;
	    const r = (color & 1) * mult * 255;
	    const g = (color >> 1 & 1) * mult * 255;
	    const b = (color >> 2 & 1) * mult * 255;
	    return [r, g, b];
	  };
	  convert.ansi256.rgb = function (args) {
	    // Handle greyscale
	    if (args >= 232) {
	      const c = (args - 232) * 10 + 8;
	      return [c, c, c];
	    }
	    args -= 16;
	    let rem;
	    const r = Math.floor(args / 36) / 5 * 255;
	    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	    const b = rem % 6 / 5 * 255;
	    return [r, g, b];
	  };
	  convert.rgb.hex = function (args) {
	    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.hex.rgb = function (args) {
	    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	    if (!match) {
	      return [0, 0, 0];
	    }
	    let colorString = match[0];
	    if (match[0].length === 3) {
	      colorString = colorString.split('').map(char => {
	        return char + char;
	      }).join('');
	    }
	    const integer = parseInt(colorString, 16);
	    const r = integer >> 16 & 0xFF;
	    const g = integer >> 8 & 0xFF;
	    const b = integer & 0xFF;
	    return [r, g, b];
	  };
	  convert.rgb.hcg = function (rgb) {
	    const r = rgb[0] / 255;
	    const g = rgb[1] / 255;
	    const b = rgb[2] / 255;
	    const max = Math.max(Math.max(r, g), b);
	    const min = Math.min(Math.min(r, g), b);
	    const chroma = max - min;
	    let grayscale;
	    let hue;
	    if (chroma < 1) {
	      grayscale = min / (1 - chroma);
	    } else {
	      grayscale = 0;
	    }
	    if (chroma <= 0) {
	      hue = 0;
	    } else if (max === r) {
	      hue = (g - b) / chroma % 6;
	    } else if (max === g) {
	      hue = 2 + (b - r) / chroma;
	    } else {
	      hue = 4 + (r - g) / chroma;
	    }
	    hue /= 6;
	    hue %= 1;
	    return [hue * 360, chroma * 100, grayscale * 100];
	  };
	  convert.hsl.hcg = function (hsl) {
	    const s = hsl[1] / 100;
	    const l = hsl[2] / 100;
	    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
	    let f = 0;
	    if (c < 1.0) {
	      f = (l - 0.5 * c) / (1.0 - c);
	    }
	    return [hsl[0], c * 100, f * 100];
	  };
	  convert.hsv.hcg = function (hsv) {
	    const s = hsv[1] / 100;
	    const v = hsv[2] / 100;
	    const c = s * v;
	    let f = 0;
	    if (c < 1.0) {
	      f = (v - c) / (1 - c);
	    }
	    return [hsv[0], c * 100, f * 100];
	  };
	  convert.hcg.rgb = function (hcg) {
	    const h = hcg[0] / 360;
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    if (c === 0.0) {
	      return [g * 255, g * 255, g * 255];
	    }
	    const pure = [0, 0, 0];
	    const hi = h % 1 * 6;
	    const v = hi % 1;
	    const w = 1 - v;
	    let mg = 0;

	    /* eslint-disable max-statements-per-line */
	    switch (Math.floor(hi)) {
	      case 0:
	        pure[0] = 1;
	        pure[1] = v;
	        pure[2] = 0;
	        break;
	      case 1:
	        pure[0] = w;
	        pure[1] = 1;
	        pure[2] = 0;
	        break;
	      case 2:
	        pure[0] = 0;
	        pure[1] = 1;
	        pure[2] = v;
	        break;
	      case 3:
	        pure[0] = 0;
	        pure[1] = w;
	        pure[2] = 1;
	        break;
	      case 4:
	        pure[0] = v;
	        pure[1] = 0;
	        pure[2] = 1;
	        break;
	      default:
	        pure[0] = 1;
	        pure[1] = 0;
	        pure[2] = w;
	    }
	    /* eslint-enable max-statements-per-line */

	    mg = (1.0 - c) * g;
	    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
	  };
	  convert.hcg.hsv = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    let f = 0;
	    if (v > 0.0) {
	      f = c / v;
	    }
	    return [hcg[0], f * 100, v * 100];
	  };
	  convert.hcg.hsl = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const l = g * (1.0 - c) + 0.5 * c;
	    let s = 0;
	    if (l > 0.0 && l < 0.5) {
	      s = c / (2 * l);
	    } else if (l >= 0.5 && l < 1.0) {
	      s = c / (2 * (1 - l));
	    }
	    return [hcg[0], s * 100, l * 100];
	  };
	  convert.hcg.hwb = function (hcg) {
	    const c = hcg[1] / 100;
	    const g = hcg[2] / 100;
	    const v = c + g * (1.0 - c);
	    return [hcg[0], (v - c) * 100, (1 - v) * 100];
	  };
	  convert.hwb.hcg = function (hwb) {
	    const w = hwb[1] / 100;
	    const b = hwb[2] / 100;
	    const v = 1 - b;
	    const c = v - w;
	    let g = 0;
	    if (c < 1) {
	      g = (v - c) / (1 - c);
	    }
	    return [hwb[0], c * 100, g * 100];
	  };
	  convert.apple.rgb = function (apple) {
	    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
	  };
	  convert.rgb.apple = function (rgb) {
	    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
	  };
	  convert.gray.rgb = function (args) {
	    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	  };
	  convert.gray.hsl = function (args) {
	    return [0, 0, args[0]];
	  };
	  convert.gray.hsv = convert.gray.hsl;
	  convert.gray.hwb = function (gray) {
	    return [0, 100, gray[0]];
	  };
	  convert.gray.cmyk = function (gray) {
	    return [0, 0, 0, gray[0]];
	  };
	  convert.gray.lab = function (gray) {
	    return [gray[0], 0, 0];
	  };
	  convert.gray.hex = function (gray) {
	    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	    const integer = (val << 16) + (val << 8) + val;
	    const string = integer.toString(16).toUpperCase();
	    return '000000'.substring(string.length) + string;
	  };
	  convert.rgb.gray = function (rgb) {
	    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	    return [val / 255 * 100];
	  };
	  return conversions;
	}

	var route;
	var hasRequiredRoute;
	function requireRoute() {
	  if (hasRequiredRoute) return route;
	  hasRequiredRoute = 1;
	  const conversions = requireConversions();

	  /*
	  	This function routes a model to all other models.
	  		all functions that are routed have a property `.conversion` attached
	  	to the returned synthetic function. This property is an array
	  	of strings, each with the steps in between the 'from' and 'to'
	  	color models (inclusive).
	  		conversions that are not possible simply are not included.
	  */

	  function buildGraph() {
	    const graph = {};
	    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
	    const models = Object.keys(conversions);
	    for (let len = models.length, i = 0; i < len; i++) {
	      graph[models[i]] = {
	        // http://jsperf.com/1-vs-infinity
	        // micro-opt, but this is simple.
	        distance: -1,
	        parent: null
	      };
	    }
	    return graph;
	  }

	  // https://en.wikipedia.org/wiki/Breadth-first_search
	  function deriveBFS(fromModel) {
	    const graph = buildGraph();
	    const queue = [fromModel]; // Unshift -> queue -> pop

	    graph[fromModel].distance = 0;
	    while (queue.length) {
	      const current = queue.pop();
	      const adjacents = Object.keys(conversions[current]);
	      for (let len = adjacents.length, i = 0; i < len; i++) {
	        const adjacent = adjacents[i];
	        const node = graph[adjacent];
	        if (node.distance === -1) {
	          node.distance = graph[current].distance + 1;
	          node.parent = current;
	          queue.unshift(adjacent);
	        }
	      }
	    }
	    return graph;
	  }
	  function link(from, to) {
	    return function (args) {
	      return to(from(args));
	    };
	  }
	  function wrapConversion(toModel, graph) {
	    const path = [graph[toModel].parent, toModel];
	    let fn = conversions[graph[toModel].parent][toModel];
	    let cur = graph[toModel].parent;
	    while (graph[cur].parent) {
	      path.unshift(graph[cur].parent);
	      fn = link(conversions[graph[cur].parent][cur], fn);
	      cur = graph[cur].parent;
	    }
	    fn.conversion = path;
	    return fn;
	  }
	  route = function (fromModel) {
	    const graph = deriveBFS(fromModel);
	    const conversion = {};
	    const models = Object.keys(graph);
	    for (let len = models.length, i = 0; i < len; i++) {
	      const toModel = models[i];
	      const node = graph[toModel];
	      if (node.parent === null) {
	        // No possible conversion, or this node is the source model.
	        continue;
	      }
	      conversion[toModel] = wrapConversion(toModel, graph);
	    }
	    return conversion;
	  };
	  return route;
	}

	var colorConvert;
	var hasRequiredColorConvert;
	function requireColorConvert() {
	  if (hasRequiredColorConvert) return colorConvert;
	  hasRequiredColorConvert = 1;
	  const conversions = requireConversions();
	  const route = requireRoute();
	  const convert = {};
	  const models = Object.keys(conversions);
	  function wrapRaw(fn) {
	    const wrappedFn = function () {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      return fn(args);
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  function wrapRounded(fn) {
	    const wrappedFn = function () {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      const arg0 = args[0];
	      if (arg0 === undefined || arg0 === null) {
	        return arg0;
	      }
	      if (arg0.length > 1) {
	        args = arg0;
	      }
	      const result = fn(args);

	      // We're assuming the result is an array here.
	      // see notice in conversions.js; don't use box types
	      // in conversion functions.
	      if (typeof result === 'object') {
	        for (let len = result.length, i = 0; i < len; i++) {
	          result[i] = Math.round(result[i]);
	        }
	      }
	      return result;
	    };

	    // Preserve .conversion property if there is one
	    if ('conversion' in fn) {
	      wrappedFn.conversion = fn.conversion;
	    }
	    return wrappedFn;
	  }
	  models.forEach(fromModel => {
	    convert[fromModel] = {};
	    Object.defineProperty(convert[fromModel], 'channels', {
	      value: conversions[fromModel].channels
	    });
	    Object.defineProperty(convert[fromModel], 'labels', {
	      value: conversions[fromModel].labels
	    });
	    const routes = route(fromModel);
	    const routeModels = Object.keys(routes);
	    routeModels.forEach(toModel => {
	      const fn = routes[toModel];
	      convert[fromModel][toModel] = wrapRounded(fn);
	      convert[fromModel][toModel].raw = wrapRaw(fn);
	    });
	  });
	  colorConvert = convert;
	  return colorConvert;
	}

	(function (module) {

	  const wrapAnsi16 = (fn, offset) => function () {
	    const code = fn(...arguments);
	    return `\u001B[${code + offset}m`;
	  };
	  const wrapAnsi256 = (fn, offset) => function () {
	    const code = fn(...arguments);
	    return `\u001B[${38 + offset};5;${code}m`;
	  };
	  const wrapAnsi16m = (fn, offset) => function () {
	    const rgb = fn(...arguments);
	    return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
	  };
	  const ansi2ansi = n => n;
	  const rgb2rgb = (r, g, b) => [r, g, b];
	  const setLazyProperty = (object, property, get) => {
	    Object.defineProperty(object, property, {
	      get: () => {
	        const value = get();
	        Object.defineProperty(object, property, {
	          value,
	          enumerable: true,
	          configurable: true
	        });
	        return value;
	      },
	      enumerable: true,
	      configurable: true
	    });
	  };

	  /** @type {typeof import('color-convert')} */
	  let colorConvert;
	  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	    if (colorConvert === undefined) {
	      colorConvert = requireColorConvert();
	    }
	    const offset = isBackground ? 10 : 0;
	    const styles = {};
	    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
	      const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
	      if (sourceSpace === targetSpace) {
	        styles[name] = wrap(identity, offset);
	      } else if (typeof suite === 'object') {
	        styles[name] = wrap(suite[targetSpace], offset);
	      }
	    }
	    return styles;
	  };
	  function assembleStyles() {
	    const codes = new Map();
	    const styles = {
	      modifier: {
	        reset: [0, 0],
	        // 21 isn't widely supported and 22 does the same thing
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        // Bright color
	        blackBright: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        // Bright color
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    };

	    // Alias bright black as gray (and grey)
	    styles.color.gray = styles.color.blackBright;
	    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	    styles.color.grey = styles.color.blackBright;
	    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
	    for (const [groupName, group] of Object.entries(styles)) {
	      for (const [styleName, style] of Object.entries(group)) {
	        styles[styleName] = {
	          open: `\u001B[${style[0]}m`,
	          close: `\u001B[${style[1]}m`
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }
	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	    }
	    Object.defineProperty(styles, 'codes', {
	      value: codes,
	      enumerable: false
	    });
	    styles.color.close = '\u001B[39m';
	    styles.bgColor.close = '\u001B[49m';
	    setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	    setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	    setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	    setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	    setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	    setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
	    return styles;
	  }

	  // Make the export immutable
	  Object.defineProperty(module, 'exports', {
	    enumerable: true,
	    get: assembleStyles
	  });
	})(ansiStyles$1);

	const isFullwidthCodePoint = isFullwidthCodePoint$2.exports;
	const astralRegex = astralRegex_1;
	const ansiStyles = ansiStyles$1.exports;
	const ESCAPES = ['\u001B', '\u009B'];
	const wrapAnsi = code => `${ESCAPES[0]}[${code}m`;
	const checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
	  let output = [];
	  ansiCodes = [...ansiCodes];
	  for (let ansiCode of ansiCodes) {
	    const ansiCodeOrigin = ansiCode;
	    if (ansiCode.includes(';')) {
	      ansiCode = ansiCode.split(';')[0][0] + '0';
	    }
	    const item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));
	    if (item) {
	      const indexEscape = ansiCodes.indexOf(item.toString());
	      if (indexEscape === -1) {
	        output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
	      } else {
	        ansiCodes.splice(indexEscape, 1);
	      }
	    } else if (isEscapes) {
	      output.push(wrapAnsi(0));
	      break;
	    } else {
	      output.push(wrapAnsi(ansiCodeOrigin));
	    }
	  }
	  if (isEscapes) {
	    output = output.filter((element, index) => output.indexOf(element) === index);
	    if (endAnsiCode !== undefined) {
	      const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));
	      output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
	    }
	  }
	  return output.join('');
	};
	var sliceAnsi = (string, begin, end) => {
	  const characters = [...string];
	  const ansiCodes = [];
	  let stringEnd = typeof end === 'number' ? end : characters.length;
	  let isInsideEscape = false;
	  let ansiCode;
	  let visible = 0;
	  let output = '';
	  for (const [index, character] of characters.entries()) {
	    let leftEscape = false;
	    if (ESCAPES.includes(character)) {
	      const code = /\d[^m]*/.exec(string.slice(index, index + 18));
	      ansiCode = code && code.length > 0 ? code[0] : undefined;
	      if (visible < stringEnd) {
	        isInsideEscape = true;
	        if (ansiCode !== undefined) {
	          ansiCodes.push(ansiCode);
	        }
	      }
	    } else if (isInsideEscape && character === 'm') {
	      isInsideEscape = false;
	      leftEscape = true;
	    }
	    if (!isInsideEscape && !leftEscape) {
	      visible++;
	    }
	    if (!astralRegex({
	      exact: true
	    }).test(character) && isFullwidthCodePoint(character.codePointAt())) {
	      visible++;
	      if (typeof end !== 'number') {
	        stringEnd++;
	      }
	    }
	    if (visible > begin && visible <= stringEnd) {
	      output += character;
	    } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {
	      output = checkAnsi(ansiCodes);
	    } else if (visible >= stringEnd) {
	      output += checkAnsi(ansiCodes, true, ansiCode);
	      break;
	    }
	  }
	  return output;
	};

	// We try to load node dependencies
	let chalk = null;
	let readFileSync = null;
	let codeFrameColumns = null;
	try {
	  const nodeRequire = module && module.require;
	  readFileSync = nodeRequire.call(module, 'fs').readFileSync;
	  codeFrameColumns = nodeRequire.call(module, '@babel/code-frame').codeFrameColumns;
	  chalk = nodeRequire.call(module, 'chalk');
	} catch (e) {
	  // We're in a browser environment
	}

	// frame has the form "at myMethod (location/to/my/file.js:10:2)"
	function getCodeFrame(frame) {
	  const locationStart = frame.indexOf('(') + 1;
	  const locationEnd = frame.indexOf(')');
	  const frameLocation = frame.slice(locationStart, locationEnd);
	  const frameLocationElements = frameLocation.split(':');
	  const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
	  let rawFileContents = '';
	  try {
	    rawFileContents = readFileSync(filename, 'utf-8');
	  } catch (e) {
	    return '';
	  }
	  const codeFrame = codeFrameColumns(rawFileContents, {
	    start: {
	      line,
	      column
	    }
	  }, {
	    highlightCode: true,
	    linesBelow: 0
	  });
	  return `${chalk.dim(frameLocation)}\n${codeFrame}\n`;
	}
	function getUserCodeFrame() {
	  // If we couldn't load dependencies, we can't generate the user trace
	  /* istanbul ignore next */
	  if (!readFileSync || !codeFrameColumns) {
	    return '';
	  }
	  const err = new Error();
	  const firstClientCodeFrame = err.stack.split('\n').slice(1) // Remove first line which has the form "Error: TypeError"
	  .find(frame => !frame.includes('node_modules/')); // Ignore frames from 3rd party libraries

	  return getCodeFrame(firstClientCodeFrame);
	}

	function prettyCLI(testInstance, maxLength) {
	  if (typeof maxLength !== 'number') {
	    maxLength = typeof process !== 'undefined' && undefined || 7000;
	  }
	  if (maxLength === 0) {
	    return '';
	  }
	  if (!('stdoutArr' in testInstance && 'stderrArr' in testInstance)) {
	    throw new TypeError(`Expected an instance but got ${testInstance}`);
	  }
	  const outStr = testInstance.getStdallStr();

	  // eslint-disable-next-line no-negated-condition
	  return maxLength !== undefined && outStr.length > maxLength ? sliceAnsi(outStr, 0, maxLength) : outStr;
	}
	const logCLI = function () {
	  const userCodeFrame = getUserCodeFrame();
	  if (userCodeFrame) {
	    process.stdout.write(`${prettyCLI(...arguments)}\n\n${userCodeFrame}`);
	  } else {
	    process.stdout.write(prettyCLI(...arguments));
	  }
	};

	const mountedInstances = new Set();
	async function render(command, args, opts) {
	  if (args === void 0) {
	    args = [];
	  }
	  if (opts === void 0) {
	    opts = {};
	  }
	  const {
	    cwd = __dirname,
	    spawnOpts = {}
	  } = opts;

	  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	  const exec = require$$0__default["default"].spawn(command, args, {
	    ...spawnOpts,
	    cwd,
	    shell: true
	  });
	  let _readyPromiseInternals = null;
	  let _resolved = false;
	  const execOutputAPI = {
	    __exitCode: null,
	    _isOutputAPI: true,
	    _isReady: new Promise((resolve, reject) => _readyPromiseInternals = {
	      resolve,
	      reject
	    }),
	    process: exec,
	    // Clear buffer of stdout to do more accurate `t.regex` checks
	    clear() {
	      execOutputAPI.stdoutArr = [];
	      execOutputAPI.stderrArr = [];
	    },
	    debug(maxLength) {
	      logCLI(execOutputAPI, maxLength);
	    },
	    // An array of strings gathered from stdout when unable to do
	    // `await stdout` because of inquirer interactive prompts
	    stdoutArr: [],
	    stderrArr: [],
	    hasExit() {
	      return this.__exitCode === null ? null : {
	        exitCode: this.__exitCode
	      };
	    }
	  };
	  mountedInstances.add(execOutputAPI);
	  exec.stdout.on('data', result => {
	    // `on('spawn') doesn't work the same way in Node12.
	    // Instead, we have to rely on this working as-expected.
	    if (_readyPromiseInternals && !_resolved) {
	      _readyPromiseInternals.resolve();
	      _resolved = true;
	    }
	    const resStr = stripFinalNewline(result);
	    execOutputAPI.stdoutArr.push({
	      contents: resStr,
	      timestamp: perf_hooks.performance.now()
	    });
	    _runObservers();
	  });
	  exec.stderr.on('data', result => {
	    if (_readyPromiseInternals && !_resolved) {
	      _readyPromiseInternals.resolve();
	      _resolved = true;
	    }
	    const resStr = stripFinalNewline(result);
	    execOutputAPI.stderrArr.push({
	      contents: resStr,
	      timestamp: perf_hooks.performance.now()
	    });
	    _runObservers();
	  });
	  exec.on('error', result => {
	    if (_readyPromiseInternals) {
	      _readyPromiseInternals.reject(result);
	    }
	  });
	  exec.on('spawn', () => {
	    setTimeout(() => {
	      if (_readyPromiseInternals && !_resolved) {
	        _readyPromiseInternals.resolve();
	        _resolved = true;
	      }
	    }, getConfig().renderAwaitTime);
	  });
	  exec.on('exit', code => {
	    execOutputAPI.__exitCode = code ?? 0;
	  });
	  setCurrentInstance(execOutputAPI);
	  await execOutputAPI._isReady;
	  function getStdallStr() {
	    return this.stderrArr.concat(this.stdoutArr).sort((a, b) => a.timestamp < b.timestamp ? -1 : 1).map(obj => obj.contents).join('\n');
	  }
	  return Object.assign(execOutputAPI, {
	    userEvent: bindObjectFnsToInstance(execOutputAPI, userEvent),
	    getStdallStr: getStdallStr.bind(execOutputAPI)
	  }, getQueriesForElement(execOutputAPI));
	}
	function cleanup() {
	  return Promise.all(Array.from(mountedInstances).map(cleanupAtInstance));
	}

	// maybe one day we'll expose this (perhaps even as a utility returned by render).
	// but let's wait until someone asks for it.
	async function cleanupAtInstance(instance) {
	  await fireEvent.sigkill(instance);
	  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	  mountedInstances.delete(instance);
	}

	// if we're running in a test runner that supports afterEach
	// or teardown then we'll automatically run cleanup afterEach test
	// this ensures that tests run in isolation from each other
	// if you don't like this then set the CTL_SKIP_AUTO_CLEANUP env variable to 'true'.
	if (typeof process === 'undefined' || !(process.env && undefined)) {
	  // ignore teardown() in code coverage because Jest does not support it
	  /* istanbul ignore else */
	  if (typeof afterEach === 'function') {
	    afterEach(async () => {
	      await cleanup();
	    });
	  } else if (typeof teardown === 'function') {
	    // Block is guarded by `typeof` check.
	    // eslint does not support `typeof` guards.
	    // eslint-disable-next-line no-undef
	    teardown(async () => {
	      await cleanup();
	    });
	  }
	}

	exports.MutationObserver = MutationObserver;
	exports._runObservers = _runObservers;
	exports.bindObjectFnsToInstance = bindObjectFnsToInstance;
	exports.buildQueries = buildQueries;
	exports.cleanup = cleanup;
	exports.configure = configure;
	exports.debounce = debounce;
	exports.findByError = findByError;
	exports.findByText = findByText;
	exports.fireEvent = fireEvent;
	exports.fuzzyMatches = fuzzyMatches;
	exports.getByError = getByError;
	exports.getByText = getByText;
	exports.getConfig = getConfig;
	exports.getCurrentInstance = getCurrentInstance;
	exports.getDefaultNormalizer = getDefaultNormalizer;
	exports.getInstanceError = getInstanceError;
	exports.getQueriesForElement = getQueriesForElement;
	exports.jestFakeTimersAreEnabled = jestFakeTimersAreEnabled;
	exports.makeFindQuery = makeFindQuery;
	exports.makeNormalizer = makeNormalizer;
	exports.matches = matches;
	exports.queryByError = queryByErrorWithSuggestions;
	exports.queryByText = queryByTextWithSuggestions;
	exports.render = render;
	exports.runWithExpensiveErrorDiagnosticsDisabled = runWithExpensiveErrorDiagnosticsDisabled;
	exports.setCurrentInstance = setCurrentInstance;
	exports.waitFor = waitForWrapper;
	exports.wrapSingleQueryWithSuggestion = wrapSingleQueryWithSuggestion;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=cli-testing-library.umd.js.map
