"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNextKeyDef = getNextKeyDef;
var bracketDict = /*#__PURE__*/function (bracketDict) {
  bracketDict["["] = "]";
  return bracketDict;
}(bracketDict || {});
/**
 * Get the next key from keyMap
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 */
function getNextKeyDef(text, options) {
  var _options$keyboardMap$;
  const {
    type,
    descriptor,
    consumedLength
  } = readNextDescriptor(text);
  const keyDef = (_options$keyboardMap$ = options.keyboardMap.find(def => {
    if (type === '[') {
      var _def$code;
      return ((_def$code = def.code) == null ? void 0 : _def$code.toLowerCase()) === descriptor.toLowerCase();
    }
    return def.hex === descriptor;
  })) != null ? _options$keyboardMap$ : {
    code: descriptor,
    hex: 'Unknown'
  };
  return {
    keyDef,
    consumedLength
  };
}
function readNextDescriptor(text) {
  let pos = 0;
  const startBracket = text[pos] in bracketDict ? text[pos] : '';
  pos += startBracket.length;

  // `foo[[bar` is an escaped char at position 3,
  // but `foo[[[>5}bar` should be treated as `{` pressed down for 5 keydowns.
  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\${startBracket}+`))[0].length : 0;
  const isEscapedChar = startBracketRepeated === 2;
  const type = isEscapedChar ? '' : startBracket;
  return {
    type,
    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))
  };
}
function readPrintableChar(text, pos) {
  const descriptor = text[pos];
  assertDescriptor(descriptor, text, pos);
  pos += descriptor.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
function readTag(text, pos, startBracket) {
  var _text$slice$match;
  const descriptor = (_text$slice$match = text.slice(pos).match(/^\w+/)) == null ? void 0 : _text$slice$match[0];
  assertDescriptor(descriptor, text, pos);
  pos += descriptor.length;
  const expectedEndBracket = bracketDict[startBracket];
  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
  if (!endBracket) {
    throw new Error(getErrorMessage(`"${expectedEndBracket}"`, text[pos], text));
  }
  pos += endBracket.length;
  return {
    consumedLength: pos,
    descriptor
  };
}
function assertDescriptor(descriptor, text, pos) {
  if (!descriptor) {
    throw new Error(getErrorMessage('key descriptor', text[pos], text));
  }
}
function getErrorMessage(expected, found, text) {
  return `Expected ${expected} but found "${found != null ? found : ''}" in "${text}"
    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options
    for more information about how userEvent parses your input.`;
}