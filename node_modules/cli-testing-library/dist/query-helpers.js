"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildQueries = buildQueries;
exports.getInstanceError = getInstanceError;
exports.makeFindQuery = makeFindQuery;
exports.wrapSingleQueryWithSuggestion = void 0;
var _suggestions = require("./suggestions");
var _waitFor = require("./wait-for");
var _config = require("./config");
function getInstanceError(message, instance) {
  return (0, _config.getConfig)().getInstanceError(message, instance);
}
function getSuggestionError(suggestion, container) {
  return (0, _config.getConfig)().getInstanceError(`A better query is available, try this:
${suggestion.toString()}
`, container);
}

// this accepts a query function and returns a function which throws an error
// if an empty list of elements is returned
function makeGetQuery(queryBy, getMissingError) {
  return (instance, ...args) => {
    const el = queryBy(instance, ...args);
    if (!el) {
      throw (0, _config.getConfig)().getInstanceError(getMissingError(instance, ...args), instance);
    }
    return el;
  };
}

// this accepts a getter query function and returns a function which calls
// waitFor and passing a function which invokes the getter.
function makeFindQuery(getter) {
  return (container, text, options, waitForOptions) => {
    return (0, _waitFor.waitFor)(() => {
      return getter(container, text, options);
    }, {
      container,
      ...waitForOptions
    });
  };
}
const wrapSingleQueryWithSuggestion = (query, queryByName, variant) => (container, ...args) => {
  const instance = query(container, ...args);
  const [{
    suggest = (0, _config.getConfig)().throwSuggestions
  } = {}] = args.slice(-1);
  if (instance && suggest) {
    const suggestion = (0, _suggestions.getSuggestedQuery)(instance, variant);
    if (suggestion && !queryByName.endsWith(suggestion.queryName)) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      throw getSuggestionError(suggestion.toString(), container);
    }
  }
  return instance;
};

// TODO: This deviates from the published declarations
// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`
// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, TestInstance[]>`
exports.wrapSingleQueryWithSuggestion = wrapSingleQueryWithSuggestion;
function buildQueries(queryBy, getMissingError) {
  const getBy = makeGetQuery(queryBy, getMissingError);
  const queryByWithSuggestions = wrapSingleQueryWithSuggestion(queryBy, queryBy.name, 'get');
  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'get');
  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'find'));
  return [queryByWithSuggestions, getByWithSuggestions, findBy];
}