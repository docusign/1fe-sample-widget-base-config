import childProcess from 'child_process';
import { performance } from 'perf_hooks';
import stripFinalNewline from 'strip-final-newline';
import stripAnsiFn from 'strip-ansi';
import treeKill from 'tree-kill';
import sliceAnsi from 'slice-ansi';

// Used for `MutationObserver`. Unsure if it's really needed, but it's worth mentioning that these are not tied to
// specific CLI instances of `render`. This means that if there are e2e CLI tests that run in parallel, they will
// execute far more frequently than needed.
const _observers = new Map();

// Not perfect as a way to make "MutationObserver" unique IDs, but it should work
let mutId = 0;
class MutationObserver {
  constructor(cb) {
    this._id = ++mutId;
    this._cb = cb;
  }
  observe() {
    _observers.set(this._id, this._cb);
  }
  disconnect() {
    _observers.delete(this._id);
  }
}
function _runObservers() {
  Array.from(_observers.values()).forEach(cb => cb());
}

function assertNotNullOrUndefined(matcher) {
  if (matcher === null || matcher === undefined) {
    throw new Error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions -- implicitly converting `T` to `string`
    `It looks like ${matcher} was passed instead of a matcher. Did you do something like getByText(${matcher})?`);
  }
}
function fuzzyMatches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch !== 'string') {
    return false;
  }
  assertNotNullOrUndefined(matcher);
  const normalizedText = normalizer(textToMatch);
  if (typeof matcher === 'string' || typeof matcher === 'number') {
    return normalizedText.toLowerCase().includes(matcher.toString().toLowerCase());
  } else if (typeof matcher === 'function') {
    return matcher(normalizedText, node);
  } else {
    return matcher.test(normalizedText);
  }
}
function matches(textToMatch, node, matcher, normalizer) {
  if (typeof textToMatch !== 'string') {
    return false;
  }
  assertNotNullOrUndefined(matcher);
  const normalizedText = normalizer(textToMatch);
  if (matcher instanceof Function) {
    return matcher(normalizedText, node);
  } else if (matcher instanceof RegExp) {
    return matcher.test(normalizedText);
  } else {
    return normalizedText === String(matcher);
  }
}
function getDefaultNormalizer(_temp) {
  let {
    trim = true,
    collapseWhitespace = true,
    stripAnsi = true
  } = _temp === void 0 ? {} : _temp;
  return text => {
    let normalizedText = text;
    normalizedText = trim ? normalizedText.trim() : normalizedText;
    normalizedText = collapseWhitespace ? normalizedText.replace(/\s+/g, ' ') : normalizedText;
    normalizedText = stripAnsi ? stripAnsiFn(normalizedText) : normalizedText;
    return normalizedText;
  };
}

/**
 * @param {Object} props
 * Constructs a normalizer to pass to functions in matches.js
 * @param {boolean|undefined} props.trim The user-specified value for `trim`, without
 * any defaulting having been applied
 * @param {boolean|undefined} props.stripAnsi The user-specified value for `stripAnsi`, without
 * any defaulting having been applied
 * @param {boolean|undefined} props.collapseWhitespace The user-specified value for
 * `collapseWhitespace`, without any defaulting having been applied
 * @param {Function|undefined} props.normalizer The user-specified normalizer
 * @returns {Function} A normalizer
 */

function makeNormalizer(_ref) {
  let {
    trim,
    stripAnsi,
    collapseWhitespace,
    normalizer
  } = _ref;
  if (normalizer) {
    // User has specified a custom normalizer
    if (typeof trim !== 'undefined' || typeof collapseWhitespace !== 'undefined' || typeof stripAnsi !== 'undefined') {
      // They've also specified a value for trim or collapseWhitespace
      throw new Error('trim and collapseWhitespace are not supported with a normalizer. ' + 'If you want to use the default trim and collapseWhitespace logic in your normalizer, ' + 'use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
    }
    return normalizer;
  } else {
    // No custom normalizer specified. Just use default.
    return getDefaultNormalizer({
      trim,
      collapseWhitespace,
      stripAnsi
    });
  }
}

const normalize = getDefaultNormalizer();
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function getRegExpMatcher(string) {
  return new RegExp(escapeRegExp(string.toLowerCase()), 'i');
}
function makeSuggestion(queryName, element, content, _ref) {
  let {
    variant,
    name
  } = _ref;
  const warning = '';
  const queryOptions = {};
  const queryArgs = [[].includes(queryName) ? content : getRegExpMatcher(content)];
  if (name) {
    queryOptions.name = getRegExpMatcher(name);
  }
  if (Object.keys(queryOptions).length > 0) {
    queryArgs.push(queryOptions);
  }
  const queryMethod = `${variant}By${queryName}`;
  return {
    queryName,
    queryMethod,
    queryArgs,
    variant,
    warning,
    toString() {
      let [text, options] = queryArgs;
      text = typeof text === 'string' ? `'${text}'` : text;
      options = options ? `, { ${Object.entries(options).map(_ref2 => {
        let [k, v] = _ref2;
        return `${k}: ${v}`;
      }).join(', ')} }` : '';
      return `${queryMethod}(${text}${options})`;
    }
  };
}
function canSuggest(currentMethod, requestedMethod, data) {
  return data && (!requestedMethod || requestedMethod.toLowerCase() === currentMethod.toLowerCase());
}
function getSuggestedQuery(instance, variant, method) {
  if (variant === void 0) {
    variant = 'get';
  }
  const textContent = normalize(instance.stdoutArr.map(obj => obj.contents).join('\n'));
  if (canSuggest('Text', method, textContent)) {
    return makeSuggestion('Text', instance, textContent, {
      variant
    });
  }
  return undefined;
}

function jestFakeTimersAreEnabled() {
  /* istanbul ignore else */
  if (typeof jest !== 'undefined' && jest !== null) {
    return (
      // legacy timers
      setTimeout._isMockFunction === true ||
      // modern timers
      // eslint-disable-next-line prefer-object-has-own
      Object.prototype.hasOwnProperty.call(setTimeout, 'clock')
    );
  }
  // istanbul ignore next
  return false;
}
const instanceRef = {
  current: undefined
};
if (typeof afterEach === 'function') {
  afterEach(() => {
    instanceRef.current = undefined;
  });
}
function getCurrentInstance() {
  /**
   * Worth mentioning that this deviates from the upstream implementation
   * of `dom-testing-library`'s `getDocument` in waitFor, which throws an error whenever
   * `window` is not defined.
   *
   * Admittedly, this is another way that `cli-testing-library` will need to figure out
   * the right solution to this problem, since there is no omni-present parent `instance`
   * in a CLI like there is in a browser. (although FWIW, "process" might work)
   *
   * Have ideas how to solve? Please let us know:
   * https://github.com/crutchcorn/cli-testing-library/issues/
   */
  return instanceRef.current;
}

// TODO: Does this need to be namespaced for each test that runs?
//  That way, we don't end up with a "singleton" that ends up wiped between
//  parallel tests.
function setCurrentInstance(newInstance) {
  instanceRef.current = newInstance;
}
function debounce(func, timeout) {
  var _this = this;
  let timer;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timer);
    timer = setTimeout(() => {
      // eslint-disable-next-line no-invalid-this
      func.apply(_this, args);
    }, timeout);
  };
}

/**
 * This is used to bind a series of functions where `instance` is the first argument
 * to an instance, removing the implicit first argument.
 */
function bindObjectFnsToInstance(instance, object) {
  return Object.entries(object).reduce((prev, _ref) => {
    let [key, fn] = _ref;
    prev[key] = function () {
      for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        props[_key2] = arguments[_key2];
      }
      return fn(instance, ...props);
    };
    return prev;
  }, {});
}

// import {prettyDOM} from './pretty-dom'

// It would be cleaner for this to live inside './queries', but
// other parts of the code assume that all exports from
// './queries' are query functions.
let config = {
  asyncUtilTimeout: 1000,
  // Short amount of time to wait for your process to spin up after a `spawn`. AFAIK There's unfortunately not much
  // of a better way to do this
  renderAwaitTime: 100,
  // Internal timer time to wait before attempting error recovery debounce action
  errorDebounceTimeout: 100,
  unstable_advanceTimersWrapper: cb => cb(),
  // default value for the `hidden` option in `ByRole` queries
  // showOriginalStackTrace flag to show the full error stack traces for async errors
  showOriginalStackTrace: false,
  // throw errors w/ suggestions for better queries. Opt in so off by default.
  throwSuggestions: false,
  // called when getBy* queries fail. (message, container) => Error
  getInstanceError(message, testInstance) {
    let instanceWarning = '';
    if (testInstance) {
      const stdallArrStr = testInstance.getStdallStr();
      instanceWarning = `\n${stdallArrStr}`;
    } else {
      instanceWarning = '';
    }
    const error = new Error([message, instanceWarning].filter(Boolean).join('\n\n'));
    error.name = 'TestingLibraryElementError';
    return error;
  },
  _disableExpensiveErrorDiagnostics: false
};
function runWithExpensiveErrorDiagnosticsDisabled(callback) {
  try {
    config._disableExpensiveErrorDiagnostics = true;
    return callback();
  } finally {
    config._disableExpensiveErrorDiagnostics = false;
  }
}
function configure(newConfig) {
  if (typeof newConfig === 'function') {
    // Pass the existing config out to the provided function
    // and accept a delta in return
    newConfig = newConfig(config);
  }

  // Merge the incoming config delta
  config = {
    ...config,
    ...newConfig
  };
}
function getConfig() {
  return config;
}

// Migrated from: https://github.com/testing-library/dom-testing-library/blob/main/src/wait-for.js

// This is so the stack trace the developer sees is one that's
// closer to their code (because async stack traces are hard to follow).
function copyStackTrace(target, source) {
  target.stack = source.stack.replace(source.message, target.message);
}
function waitFor(callback, _ref) {
  let {
    instance = getCurrentInstance(),
    timeout = getConfig().asyncUtilTimeout,
    showOriginalStackTrace = getConfig().showOriginalStackTrace,
    stackTraceError,
    interval = 50,
    onTimeout = error => {
      error.message = getConfig().getInstanceError(error.message, instance).message;
      return error;
    }
  } = _ref;
  if (typeof callback !== 'function') {
    throw new TypeError('Received `callback` arg must be a function');
  }
  return new Promise(async (resolve, reject) => {
    let lastError, intervalId, observer;
    let finished = false;
    let promiseStatus = 'idle';
    const overallTimeoutTimer = setTimeout(handleTimeout, timeout);
    const usingJestFakeTimers = jestFakeTimersAreEnabled();
    if (usingJestFakeTimers) {
      const {
        unstable_advanceTimersWrapper: advanceTimersWrapper
      } = getConfig();
      checkCallback();
      // this is a dangerous rule to disable because it could lead to an
      // infinite loop. However, eslint isn't smart enough to know that we're
      // setting finished inside `onDone` which will be called when we're done
      // waiting or when we've timed out.
      // eslint-disable-next-line no-unmodified-loop-condition
      while (!finished) {
        if (!jestFakeTimersAreEnabled()) {
          const error = new Error(`Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
          if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
          reject(error);
          return;
        }
        // we *could* (maybe should?) use `advanceTimersToNextTimer` but it's
        // possible that could make this loop go on forever if someone is using
        // third party code that's setting up recursive timers so rapidly that
        // the user's timer's don't get a chance to resolve. So we'll advance
        // by an interval instead. (We have a test for this case).
        advanceTimersWrapper(() => {
          jest.advanceTimersByTime(interval);
        });

        // It's really important that checkCallback is run *before* we flush
        // in-flight promises. To be honest, I'm not sure why, and I can't quite
        // think of a way to reproduce the problem in a test, but I spent
        // an entire day banging my head against a wall on this.
        checkCallback();

        // In this rare case, we *need* to wait for in-flight promises
        // to resolve before continuing. We don't need to take advantage
        // of parallelization so we're fine.
        // https://stackoverflow.com/a/59243586/971592
        // eslint-disable-next-line no-await-in-loop
        await advanceTimersWrapper(async () => {
          await new Promise(r => {
            setTimeout(r, 0);
            jest.advanceTimersByTime(0);
          });
        });
      }
    } else {
      intervalId = setInterval(checkRealTimersCallback, interval);
      observer = new MutationObserver(checkRealTimersCallback);
      observer.observe();
      checkCallback();
    }
    function onDone(error, result) {
      finished = true;
      clearTimeout(overallTimeoutTimer);
      if (!usingJestFakeTimers) {
        clearInterval(intervalId);
        observer.disconnect();
      }
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    }
    function checkRealTimersCallback() {
      if (jestFakeTimersAreEnabled()) {
        const error = new Error(`Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830`);
        if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
        return reject(error);
      } else {
        return checkCallback();
      }
    }
    function checkCallback() {
      if (promiseStatus === 'pending') return;
      try {
        const result = callback(); // runWithExpensiveErrorDiagnosticsDisabled(callback)
        if (typeof (result && result.then) === 'function') {
          promiseStatus = 'pending';
          result.then(resolvedValue => {
            promiseStatus = 'resolved';
            onDone(null, resolvedValue);
          }, rejectedValue => {
            promiseStatus = 'rejected';
            lastError = rejectedValue;
          });
        } else {
          onDone(null, result);
        }
        // If `callback` throws, wait for the next mutation, interval, or timeout.
      } catch (error) {
        // Save the most recent callback error to reject the promise with it in the event of a timeout
        lastError = error;
      }
    }
    function handleTimeout() {
      let error;
      if (lastError) {
        error = lastError;
        if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {
          copyStackTrace(error, stackTraceError);
        }
      } else {
        error = new Error('Timed out in waitFor.');
        if (!showOriginalStackTrace) {
          copyStackTrace(error, stackTraceError);
        }
      }
      onDone(onTimeout(error), null);
    }
  });
}
function waitForWrapper(callback, options) {
  // create the error here so its stack trace is as close to the
  // calling code as possible
  const stackTraceError = new Error('STACK_TRACE_MESSAGE');
  return waitFor(callback, {
    stackTraceError,
    ...options
  });
}

/*
eslint
  max-lines-per-function: ["error", {"max": 200}],
*/

function getInstanceError(message, instance) {
  return getConfig().getInstanceError(message, instance);
}
function getSuggestionError(suggestion, container) {
  return getConfig().getInstanceError(`A better query is available, try this:
${suggestion.toString()}
`, container);
}

// this accepts a query function and returns a function which throws an error
// if an empty list of elements is returned
function makeGetQuery(queryBy, getMissingError) {
  return function (instance) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const el = queryBy(instance, ...args);
    if (!el) {
      throw getConfig().getInstanceError(getMissingError(instance, ...args), instance);
    }
    return el;
  };
}

// this accepts a getter query function and returns a function which calls
// waitFor and passing a function which invokes the getter.
function makeFindQuery(getter) {
  return (container, text, options, waitForOptions) => {
    return waitForWrapper(() => {
      return getter(container, text, options);
    }, {
      container,
      ...waitForOptions
    });
  };
}
const wrapSingleQueryWithSuggestion = (query, queryByName, variant) => function (container) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const instance = query(container, ...args);
  const [{
    suggest = getConfig().throwSuggestions
  } = {}] = args.slice(-1);
  if (instance && suggest) {
    const suggestion = getSuggestedQuery(instance, variant);
    if (suggestion && !queryByName.endsWith(suggestion.queryName)) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      throw getSuggestionError(suggestion.toString(), container);
    }
  }
  return instance;
};

// TODO: This deviates from the published declarations
// However, the implementation always required a dyadic (after `container`) not variadic `queryAllBy` considering the implementation of `makeFindQuery`
// This is at least statically true and can be verified by accepting `QueryMethod<Arguments, TestInstance[]>`
function buildQueries(queryBy, getMissingError) {
  const getBy = makeGetQuery(queryBy, getMissingError);
  const queryByWithSuggestions = wrapSingleQueryWithSuggestion(queryBy, queryBy.name, 'get');
  const getByWithSuggestions = wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'get');
  const findBy = makeFindQuery(wrapSingleQueryWithSuggestion(getBy, queryBy.name, 'find'));
  return [queryByWithSuggestions, getByWithSuggestions, findBy];
}

const queryByTextBase = function (instance, text, _temp) {
  let {
    exact = false,
    collapseWhitespace,
    trim,
    normalizer,
    stripAnsi
  } = _temp === void 0 ? {} : _temp;
  const matcher = exact ? matches : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    stripAnsi,
    collapseWhitespace,
    trim,
    normalizer
  });
  const str = instance.stdoutArr.map(output => output.contents).join('\n');
  if (matcher(str, instance, text, matchNormalizer)) return instance;else return null;
};
const getMissingError$1 = (c, text) => `Unable to find an stdout line with the text: ${text}. This could be because the text is broken up by multiple lines. In this case, you can provide a function for your text matcher to make your matcher more flexible.`;
const [queryByTextWithSuggestions, getByText, findByText] = buildQueries(queryByTextBase, getMissingError$1);

const queryByErrorBase = function (instance, text, _temp) {
  let {
    exact = false,
    collapseWhitespace,
    trim,
    normalizer,
    stripAnsi
  } = _temp === void 0 ? {} : _temp;
  const matcher = exact ? matches : fuzzyMatches;
  const matchNormalizer = makeNormalizer({
    stripAnsi,
    collapseWhitespace,
    trim,
    normalizer
  });
  const str = instance.stderrArr.map(obj => obj.contents).join('\n');
  if (matcher(str, instance, text, matchNormalizer)) return instance;else return null;
};
const getMissingError = (c, text) => `Unable to find an stdout line with the text: ${text}. This could be because the text is broken up by multiple lines. In this case, you can provide a function for your text matcher to make your matcher more flexible.`;
const [queryByErrorWithSuggestions, getByError, findByError] = buildQueries(queryByErrorBase, getMissingError);

var defaultQueries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  queryByText: queryByTextWithSuggestions,
  getByText: getByText,
  findByText: findByText,
  queryByError: queryByErrorWithSuggestions,
  getByError: getByError,
  findByError: findByError
});

/**
 * @typedef {{[key: string]: Function}} FuncMap
 */

/**
 * @param {TestInstance} instance
 * @param {FuncMap} queries object of functions
 * @param {Object} initialValue for reducer
 * @returns {FuncMap} returns object of functions bound to container
 */
function getQueriesForElement(instance, queries, initialValue) {
  if (queries === void 0) {
    queries = defaultQueries;
  }
  if (initialValue === void 0) {
    initialValue = {};
  }
  return Object.keys(queries).reduce((helpers, key) => {
    const fn = queries[key];
    helpers[key] = fn.bind(null, instance);
    return helpers;
  }, initialValue);
}

const killProc = (instance, signal) => new Promise((resolve, reject) => {
  if (!instance.process.pid || instance.process.pid && instance.hasExit()) {
    resolve();
    return;
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  treeKill(instance.process.pid, signal, async err => {
    try {
      if (err) {
        if (err.message.includes('The process') && err.message.includes('not found.')) {
          resolve();
          return;
        }
        if (err.message.includes('could not be terminated') && err.message.includes('There is no running instance of the task.') && instance.hasExit()) {
          resolve();
          return;
        }
        const isOperationNotSupported = err.message.includes('The operation attempted is not supported.');
        const isAccessDenied = err.message.includes('Access is denied.');
        if (err.message.includes('could not be terminated') && (isOperationNotSupported || isAccessDenied)) {
          const sleep = t => new Promise(r => setTimeout(r, t));
          await sleep(getConfig().errorDebounceTimeout);
          if (instance.hasExit()) {
            resolve();
            return;
          }
          console.warn('Ran into error while trying to kill process:');
          console.warn(err.toString());
          console.warn(`This is likely due to Window's permissions.
                Because this error is prevalent on CI Windows systems with the tree-kill package, we are attempting
                 an alternative kill method.`);
          console.warn();
          console.warn('Be aware that this alternative kill method is not guaranteed to work with subprocesses, and they may not exit properly as a result.');
          const didKill = instance.process.kill(signal);
          if (didKill) {
            resolve();
          } else {
            console.error('Alternative kill method failed. Rejecting with original error.');
            reject(err);
          }
          return;
        }
        reject(err);
      } else resolve();
    } catch (e) {
      reject(e);
    }
  });
});

const isWin = process.platform === 'win32';
const eventMap = {
  sigterm: instance => killProc(instance, isWin ? undefined : 'SIGTERM'),
  sigkill: instance => killProc(instance, isWin ? undefined : 'SIGKILL'),
  write: (instance, props) => instance.process.stdin.write(props.value)
};

/**
 * Silence TypeScript errors
 * @type {*}
 */
const fireEvent = function (instance, event, props) {
  if (props === void 0) {
    props = undefined;
  }
  eventMap[event](instance, props);
};
Object.entries(eventMap).forEach(_ref => {
  let [eventName, eventFn] = _ref;
  fireEvent[eventName] = function (instance) {
    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      props[_key - 1] = arguments[_key];
    }
    eventFn(instance, ...props);
  };
});

function wait(time) {
  return new Promise(resolve => setTimeout(() => resolve(), time));
}

var bracketDict = /*#__PURE__*/function (bracketDict) {
  bracketDict["["] = "]";
  return bracketDict;
}(bracketDict || {});
/**
 * Get the next key from keyMap
 *
 * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.
 * Everything else will be interpreted as a typed character - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 */
function getNextKeyDef(text, options) {
  const {
    type,
    descriptor,
    consumedLength
  } = readNextDescriptor(text);
  const keyDef = options.keyboardMap.find(def => {
    if (type === '[') {
      return def.code?.toLowerCase() === descriptor.toLowerCase();
    }
    return def.hex === descriptor;
  }) ?? {
    code: descriptor,
    hex: 'Unknown'
  };
  return {
    keyDef,
    consumedLength
  };
}
function readNextDescriptor(text) {
  let pos = 0;
  const startBracket = text[pos] in bracketDict ? text[pos] : '';
  pos += startBracket.length;

  // `foo[[bar` is an escaped char at position 3,
  // but `foo[[[>5}bar` should be treated as `{` pressed down for 5 keydowns.
  const startBracketRepeated = startBracket ? text.match(new RegExp(`^\\${startBracket}+`))[0].length : 0;
  const isEscapedChar = startBracketRepeated === 2;
  const type = isEscapedChar ? '' : startBracket;
  return {
    type,
    ...(type === '' ? readPrintableChar(text, pos) : readTag(text, pos, type))
  };
}
function readPrintableChar(text, pos) {
  const descriptor = text[pos];
  assertDescriptor(descriptor, text, pos);
  pos += descriptor.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
function readTag(text, pos, startBracket) {
  const descriptor = text.slice(pos).match(/^\w+/)?.[0];
  assertDescriptor(descriptor, text, pos);
  pos += descriptor.length;
  const expectedEndBracket = bracketDict[startBracket];
  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
  if (!endBracket) {
    throw new Error(getErrorMessage(`"${expectedEndBracket}"`, text[pos], text));
  }
  pos += endBracket.length;
  return {
    consumedLength: pos,
    descriptor
  };
}
function assertDescriptor(descriptor, text, pos) {
  if (!descriptor) {
    throw new Error(getErrorMessage('key descriptor', text[pos], text));
  }
}
function getErrorMessage(expected, found, text) {
  return `Expected ${expected} but found "${found ?? ''}" in "${text}"
    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options
    for more information about how userEvent parses your input.`;
}

async function keyboardImplementation(instance, text, options) {
  const {
    keyDef,
    consumedLength
  } = getNextKeyDef(text, options);
  keypress(keyDef, instance);
  if (text.length > consumedLength) {
    if (options.delay > 0) {
      await wait(options.delay);
    }
    return keyboardImplementation(instance, text.slice(consumedLength), options);
  }
  return void undefined;
}
function keypress(keyDef, instance) {
  fireEvent.write(instance, {
    value: keyDef.hex
  });
}

/**
 * Mapping for a default US-104-QWERTY keyboard
 *
 * These use ANSI-C quoting, which seems to work for Linux, macOS, and Windows alike
 * @see https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#ANSI_002dC-Quoting
 * @see https://stackoverflow.com/questions/35429671/detecting-key-press-within-bash-scripts
 * @see https://gist.github.com/crutchcorn/2811db78a7b924cf54f4507198427fd2
 */
const defaultKeyMap = [
// alphanumeric keys
{
  code: 'Digit!',
  hex: '\x21'
}, {
  code: 'Digit#',
  hex: '\x23'
}, {
  code: 'Digit$',
  hex: '\x24'
}, {
  code: 'Digit%',
  hex: '\x25'
}, {
  code: 'Digit&',
  hex: '\x26'
}, {
  code: 'Digit(',
  hex: '\x29'
}, {
  code: 'Digit)',
  hex: '\x29'
}, {
  code: 'Digit*',
  hex: '\x2a'
}, {
  code: 'Digit-',
  hex: '\x2d'
}, {
  code: 'Digit@',
  hex: '\x40'
}, {
  code: 'Digit^',
  hex: '\x5e'
}, {
  code: 'Digit{',
  hex: '\x7b'
}, {
  code: 'Digit|',
  hex: '\x7c'
}, {
  code: 'Digit}',
  hex: '\x7d'
}, {
  code: 'Digit~',
  hex: '\x7e'
}, {
  code: 'Digit0',
  hex: '\x30'
}, {
  code: 'Digit1',
  hex: '\x31'
}, {
  code: 'Digit2',
  hex: '\x32'
}, {
  code: 'Digit3',
  hex: '\x33'
}, {
  code: 'Digit4',
  hex: '\x34'
}, {
  code: 'Digit5',
  hex: '\x35'
}, {
  code: 'Digit6',
  hex: '\x36'
}, {
  code: 'Digit7',
  hex: '\x37'
}, {
  code: 'Digit8',
  hex: '\x38'
}, {
  code: 'Digit9',
  hex: '\x39'
}, {
  code: 'KeyA',
  hex: '\x41'
}, {
  code: 'KeyB',
  hex: '\x42'
}, {
  code: 'KeyC',
  hex: '\x43'
}, {
  code: 'KeyD',
  hex: '\x44'
}, {
  code: 'KeyE',
  hex: '\x45'
}, {
  code: 'KeyF',
  hex: '\x46'
}, {
  code: 'KeyG',
  hex: '\x47'
}, {
  code: 'KeyH',
  hex: '\x48'
}, {
  code: 'KeyI',
  hex: '\x49'
}, {
  code: 'KeyJ',
  hex: '\x4a'
}, {
  code: 'KeyK',
  hex: '\x4b'
}, {
  code: 'KeyL',
  hex: '\x4c'
}, {
  code: 'KeyM',
  hex: '\x4d'
}, {
  code: 'KeyN',
  hex: '\x4e'
}, {
  code: 'KeyO',
  hex: '\x4f'
}, {
  code: 'KeyP',
  hex: '\x50'
}, {
  code: 'KeyQ',
  hex: '\x51'
}, {
  code: 'KeyR',
  hex: '\x52'
}, {
  code: 'KeyS',
  hex: '\x53'
}, {
  code: 'KeyT',
  hex: '\x54'
}, {
  code: 'KeyU',
  hex: '\x55'
}, {
  code: 'KeyV',
  hex: '\x56'
}, {
  code: 'KeyW',
  hex: '\x57'
}, {
  code: 'KeyX',
  hex: '\x58'
}, {
  code: 'KeyY',
  hex: '\x59'
}, {
  code: 'KeyZ',
  hex: '\x5a'
}, {
  code: 'Digit_',
  hex: '\x5f'
}, {
  code: 'KeyLowerA',
  hex: '\x61'
}, {
  code: 'KeyLowerB',
  hex: '\x62'
}, {
  code: 'KeyLowerC',
  hex: '\x63'
}, {
  code: 'KeyLowerD',
  hex: '\x64'
}, {
  code: 'KeyLowerE',
  hex: '\x65'
}, {
  code: 'KeyLowerF',
  hex: '\x66'
}, {
  code: 'KeyLowerG',
  hex: '\x67'
}, {
  code: 'KeyLowerH',
  hex: '\x68'
}, {
  code: 'KeyLowerI',
  hex: '\x69'
}, {
  code: 'KeyLowerJ',
  hex: '\x6a'
}, {
  code: 'KeyLowerK',
  hex: '\x6b'
}, {
  code: 'KeyLowerL',
  hex: '\x6c'
}, {
  code: 'KeyLowerM',
  hex: '\x6d'
}, {
  code: 'KeyLowerN',
  hex: '\x6e'
}, {
  code: 'KeyLowerO',
  hex: '\x6f'
}, {
  code: 'KeyLowerP',
  hex: '\x70'
}, {
  code: 'KeyLowerQ',
  hex: '\x71'
}, {
  code: 'KeyLowerR',
  hex: '\x72'
}, {
  code: 'KeyLowerS',
  hex: '\x73'
}, {
  code: 'KeyLowerT',
  hex: '\x74'
}, {
  code: 'KeyLowerU',
  hex: '\x75'
}, {
  code: 'KeyLowerV',
  hex: '\x76'
}, {
  code: 'KeyLowerW',
  hex: '\x77'
}, {
  code: 'KeyLowerX',
  hex: '\x78'
}, {
  code: 'KeyLowerY',
  hex: '\x79'
}, {
  code: 'KeyLowerZ',
  hex: '\x7a'
},
// alphanumeric block - functional
{
  code: 'Space',
  hex: '\x20'
}, {
  code: 'Backspace',
  hex: '\x08'
}, {
  code: 'Enter',
  hex: '\x0D'
},
// function
{
  code: 'Escape',
  hex: '\x1b'
},
// arrows
{
  code: 'ArrowUp',
  hex: '\x1b\x5b\x41'
}, {
  code: 'ArrowDown',
  hex: '\x1B\x5B\x42'
}, {
  code: 'ArrowLeft',
  hex: '\x1b\x5b\x44'
}, {
  code: 'ArrowRight',
  hex: '\x1b\x5b\x43'
},
// control pad
{
  code: 'Home',
  hex: '\x1b\x4f\x48'
}, {
  code: 'End',
  hex: '\x1b\x4f\x46'
}, {
  code: 'Delete',
  hex: '\x1b\x5b\x33\x7e'
}, {
  code: 'PageUp',
  hex: '\x1b\x5b\x35\x7e'
}, {
  code: 'PageDown',
  hex: '\x1b\x5b\x36\x7e'
}

// TODO: add mappings
];

function keyboard(instance, text, options) {
  const {
    promise
  } = keyboardImplementationWrapper(instance, text, options);
  if ((options?.delay ?? 0) > 0) {
    return promise;
  } else {
    // prevent users from dealing with UnhandledPromiseRejectionWarning in sync call
    promise.catch(console.error);
  }
}
function keyboardImplementationWrapper(instance, text, config) {
  if (config === void 0) {
    config = {};
  }
  const {
    delay = 0,
    keyboardMap = defaultKeyMap
  } = config;
  const options = {
    delay,
    keyboardMap
  };
  return {
    promise: keyboardImplementation(instance, text, options)
  };
}

const userEvent = {
  keyboard
};

// We try to load node dependencies
let chalk = null;
let readFileSync = null;
let codeFrameColumns = null;
try {
  const nodeRequire = module && module.require;
  readFileSync = nodeRequire.call(module, 'fs').readFileSync;
  codeFrameColumns = nodeRequire.call(module, '@babel/code-frame').codeFrameColumns;
  chalk = nodeRequire.call(module, 'chalk');
} catch (e) {
  // We're in a browser environment
}

// frame has the form "at myMethod (location/to/my/file.js:10:2)"
function getCodeFrame(frame) {
  const locationStart = frame.indexOf('(') + 1;
  const locationEnd = frame.indexOf(')');
  const frameLocation = frame.slice(locationStart, locationEnd);
  const frameLocationElements = frameLocation.split(':');
  const [filename, line, column] = [frameLocationElements[0], parseInt(frameLocationElements[1], 10), parseInt(frameLocationElements[2], 10)];
  let rawFileContents = '';
  try {
    rawFileContents = readFileSync(filename, 'utf-8');
  } catch (e) {
    return '';
  }
  const codeFrame = codeFrameColumns(rawFileContents, {
    start: {
      line,
      column
    }
  }, {
    highlightCode: true,
    linesBelow: 0
  });
  return `${chalk.dim(frameLocation)}\n${codeFrame}\n`;
}
function getUserCodeFrame() {
  // If we couldn't load dependencies, we can't generate the user trace
  /* istanbul ignore next */
  if (!readFileSync || !codeFrameColumns) {
    return '';
  }
  const err = new Error();
  const firstClientCodeFrame = err.stack.split('\n').slice(1) // Remove first line which has the form "Error: TypeError"
  .find(frame => !frame.includes('node_modules/')); // Ignore frames from 3rd party libraries

  return getCodeFrame(firstClientCodeFrame);
}

function prettyCLI(testInstance, maxLength) {
  if (typeof maxLength !== 'number') {
    maxLength = typeof process !== 'undefined' && process.env.DEBUG_PRINT_LIMIT || 7000;
  }
  if (maxLength === 0) {
    return '';
  }
  if (!('stdoutArr' in testInstance && 'stderrArr' in testInstance)) {
    throw new TypeError(`Expected an instance but got ${testInstance}`);
  }
  const outStr = testInstance.getStdallStr();

  // eslint-disable-next-line no-negated-condition
  return maxLength !== undefined && outStr.length > maxLength ? sliceAnsi(outStr, 0, maxLength) : outStr;
}
const logCLI = function () {
  const userCodeFrame = getUserCodeFrame();
  if (userCodeFrame) {
    process.stdout.write(`${prettyCLI(...arguments)}\n\n${userCodeFrame}`);
  } else {
    process.stdout.write(prettyCLI(...arguments));
  }
};

const mountedInstances = new Set();
async function render(command, args, opts) {
  if (args === void 0) {
    args = [];
  }
  if (opts === void 0) {
    opts = {};
  }
  const {
    cwd = __dirname,
    spawnOpts = {}
  } = opts;

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  const exec = childProcess.spawn(command, args, {
    ...spawnOpts,
    cwd,
    shell: true
  });
  let _readyPromiseInternals = null;
  let _resolved = false;
  const execOutputAPI = {
    __exitCode: null,
    _isOutputAPI: true,
    _isReady: new Promise((resolve, reject) => _readyPromiseInternals = {
      resolve,
      reject
    }),
    process: exec,
    // Clear buffer of stdout to do more accurate `t.regex` checks
    clear() {
      execOutputAPI.stdoutArr = [];
      execOutputAPI.stderrArr = [];
    },
    debug(maxLength) {
      logCLI(execOutputAPI, maxLength);
    },
    // An array of strings gathered from stdout when unable to do
    // `await stdout` because of inquirer interactive prompts
    stdoutArr: [],
    stderrArr: [],
    hasExit() {
      return this.__exitCode === null ? null : {
        exitCode: this.__exitCode
      };
    }
  };
  mountedInstances.add(execOutputAPI);
  exec.stdout.on('data', result => {
    // `on('spawn') doesn't work the same way in Node12.
    // Instead, we have to rely on this working as-expected.
    if (_readyPromiseInternals && !_resolved) {
      _readyPromiseInternals.resolve();
      _resolved = true;
    }
    const resStr = stripFinalNewline(result);
    execOutputAPI.stdoutArr.push({
      contents: resStr,
      timestamp: performance.now()
    });
    _runObservers();
  });
  exec.stderr.on('data', result => {
    if (_readyPromiseInternals && !_resolved) {
      _readyPromiseInternals.resolve();
      _resolved = true;
    }
    const resStr = stripFinalNewline(result);
    execOutputAPI.stderrArr.push({
      contents: resStr,
      timestamp: performance.now()
    });
    _runObservers();
  });
  exec.on('error', result => {
    if (_readyPromiseInternals) {
      _readyPromiseInternals.reject(result);
    }
  });
  exec.on('spawn', () => {
    setTimeout(() => {
      if (_readyPromiseInternals && !_resolved) {
        _readyPromiseInternals.resolve();
        _resolved = true;
      }
    }, getConfig().renderAwaitTime);
  });
  exec.on('exit', code => {
    execOutputAPI.__exitCode = code ?? 0;
  });
  setCurrentInstance(execOutputAPI);
  await execOutputAPI._isReady;
  function getStdallStr() {
    return this.stderrArr.concat(this.stdoutArr).sort((a, b) => a.timestamp < b.timestamp ? -1 : 1).map(obj => obj.contents).join('\n');
  }
  return Object.assign(execOutputAPI, {
    userEvent: bindObjectFnsToInstance(execOutputAPI, userEvent),
    getStdallStr: getStdallStr.bind(execOutputAPI)
  }, getQueriesForElement(execOutputAPI));
}
function cleanup() {
  return Promise.all(Array.from(mountedInstances).map(cleanupAtInstance));
}

// maybe one day we'll expose this (perhaps even as a utility returned by render).
// but let's wait until someone asks for it.
async function cleanupAtInstance(instance) {
  await fireEvent.sigkill(instance);
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  mountedInstances.delete(instance);
}

// if we're running in a test runner that supports afterEach
// or teardown then we'll automatically run cleanup afterEach test
// this ensures that tests run in isolation from each other
// if you don't like this then set the CTL_SKIP_AUTO_CLEANUP env variable to 'true'.
if (typeof process === 'undefined' || !(process.env && process.env.CTL_SKIP_AUTO_CLEANUP)) {
  // ignore teardown() in code coverage because Jest does not support it
  /* istanbul ignore else */
  if (typeof afterEach === 'function') {
    afterEach(async () => {
      await cleanup();
    });
  } else if (typeof teardown === 'function') {
    // Block is guarded by `typeof` check.
    // eslint does not support `typeof` guards.
    // eslint-disable-next-line no-undef
    teardown(async () => {
      await cleanup();
    });
  }
}

export { MutationObserver, _runObservers, bindObjectFnsToInstance, buildQueries, cleanup, configure, debounce, findByError, findByText, fireEvent, fuzzyMatches, getByError, getByText, getConfig, getCurrentInstance, getDefaultNormalizer, getInstanceError, getQueriesForElement, jestFakeTimersAreEnabled, makeFindQuery, makeNormalizer, matches, queryByErrorWithSuggestions as queryByError, queryByTextWithSuggestions as queryByText, render, runWithExpensiveErrorDiagnosticsDisabled, setCurrentInstance, waitForWrapper as waitFor, wrapSingleQueryWithSuggestion };
