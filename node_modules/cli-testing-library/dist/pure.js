"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanup = cleanup;
exports.render = render;
var _child_process = _interopRequireDefault(require("child_process"));
var _perf_hooks = require("perf_hooks");
var _stripFinalNewline = _interopRequireDefault(require("strip-final-newline"));
var _mutationObserver = require("./mutation-observer");
var _getQueriesForInstance = require("./get-queries-for-instance");
var _index = _interopRequireDefault(require("./user-event/index"));
var _helpers = require("./helpers");
var _events = require("./events");
var _config = require("./config");
var _prettyCli = require("./pretty-cli");
const mountedInstances = new Set();
async function render(command, args = [], opts = {}) {
  const {
    cwd = __dirname,
    spawnOpts = {}
  } = opts;

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  const exec = _child_process.default.spawn(command, args, {
    ...spawnOpts,
    cwd,
    shell: true
  });
  let _readyPromiseInternals = null;
  let _resolved = false;
  const execOutputAPI = {
    __exitCode: null,
    _isOutputAPI: true,
    _isReady: new Promise((resolve, reject) => _readyPromiseInternals = {
      resolve,
      reject
    }),
    process: exec,
    // Clear buffer of stdout to do more accurate `t.regex` checks
    clear() {
      execOutputAPI.stdoutArr = [];
      execOutputAPI.stderrArr = [];
    },
    debug(maxLength) {
      (0, _prettyCli.logCLI)(execOutputAPI, maxLength);
    },
    // An array of strings gathered from stdout when unable to do
    // `await stdout` because of inquirer interactive prompts
    stdoutArr: [],
    stderrArr: [],
    hasExit() {
      return this.__exitCode === null ? null : {
        exitCode: this.__exitCode
      };
    }
  };
  mountedInstances.add(execOutputAPI);
  exec.stdout.on('data', result => {
    // `on('spawn') doesn't work the same way in Node12.
    // Instead, we have to rely on this working as-expected.
    if (_readyPromiseInternals && !_resolved) {
      _readyPromiseInternals.resolve();
      _resolved = true;
    }
    const resStr = (0, _stripFinalNewline.default)(result);
    execOutputAPI.stdoutArr.push({
      contents: resStr,
      timestamp: _perf_hooks.performance.now()
    });
    (0, _mutationObserver._runObservers)();
  });
  exec.stderr.on('data', result => {
    if (_readyPromiseInternals && !_resolved) {
      _readyPromiseInternals.resolve();
      _resolved = true;
    }
    const resStr = (0, _stripFinalNewline.default)(result);
    execOutputAPI.stderrArr.push({
      contents: resStr,
      timestamp: _perf_hooks.performance.now()
    });
    (0, _mutationObserver._runObservers)();
  });
  exec.on('error', result => {
    if (_readyPromiseInternals) {
      _readyPromiseInternals.reject(result);
    }
  });
  exec.on('spawn', () => {
    setTimeout(() => {
      if (_readyPromiseInternals && !_resolved) {
        _readyPromiseInternals.resolve();
        _resolved = true;
      }
    }, (0, _config.getConfig)().renderAwaitTime);
  });
  exec.on('exit', code => {
    execOutputAPI.__exitCode = code != null ? code : 0;
  });
  (0, _helpers.setCurrentInstance)(execOutputAPI);
  await execOutputAPI._isReady;
  function getStdallStr() {
    return this.stderrArr.concat(this.stdoutArr).sort((a, b) => a.timestamp < b.timestamp ? -1 : 1).map(obj => obj.contents).join('\n');
  }
  return Object.assign(execOutputAPI, {
    userEvent: (0, _helpers.bindObjectFnsToInstance)(execOutputAPI, _index.default),
    getStdallStr: getStdallStr.bind(execOutputAPI)
  }, (0, _getQueriesForInstance.getQueriesForElement)(execOutputAPI));
}
function cleanup() {
  return Promise.all(Array.from(mountedInstances).map(cleanupAtInstance));
}

// maybe one day we'll expose this (perhaps even as a utility returned by render).
// but let's wait until someone asks for it.
async function cleanupAtInstance(instance) {
  await _events.fireEvent.sigkill(instance);
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  mountedInstances.delete(instance);
}