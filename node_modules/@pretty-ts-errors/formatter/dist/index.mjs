// src/formatTypeBlock.ts
import { format } from "prettier";

// ../utils/src/index.ts
var keys = (object) => Object.keys(object);
var values = (object) => Object.values(object);
var has = (array, item) => array.includes(item);
var invert = (obj) => {
  if (!obj) {
    return {};
  }
  const keys2 = Object.keys(obj);
  return keys2.reduce((acc, key) => {
    acc[obj[key]] = key;
    return acc;
  }, {});
};

// src/addMissingParentheses.ts
var parentheses = {
  "(": ")",
  "{": "}",
  "[": "]"
};
var openParentheses = keys(parentheses);
var closeParentheses = values(parentheses);
function addMissingParentheses(type) {
  let openStack = [];
  let missingClosingChars = "";
  for (const char of type) {
    if (has(openParentheses, char)) {
      openStack.push(char);
    } else if (has(closeParentheses, char)) {
      if (openStack.length === 0 || parentheses[openStack[openStack.length - 1]] !== char) {
        openStack.push(invert(parentheses)[char]);
      } else {
        openStack.pop();
      }
    }
  }
  while (openStack.length > 0) {
    const openChar = openStack.pop();
    const closingChar = parentheses[openChar];
    missingClosingChars += closingChar;
  }
  let validType = type;
  if ((validType.match(/\"/g) ?? []).length % 2 === 1) {
    validType = validType + '..."';
  }
  if ((validType.match(/\'/g) ?? []).length % 2 === 1) {
    validType = validType + "...'";
  }
  validType = (validType + missingClosingChars).replace(
    // Change (param: ...) to (param) => __RETURN_TYPE__ if needed
    /(\([a-zA-Z0-9]*\:.*\))/,
    (p1) => `${p1} => ...`
  );
  return validType;
}

// src/formatTypeBlock.ts
function formatTypeBlock(prefix, type, codeBlock) {
  if (type.match(/^(\[\]|\{\})$/)) {
    return `${prefix} ${codeBlock(type)}`;
  }
  if (
    // Skip formatting if it's a simple type
    type.match(
      /^((void|null|undefined|any|number|string|bigint|symbol|readonly|typeof)(\[\])?)$/
    )
  ) {
    return `${prefix} ${codeBlock(type, "type")}`;
  }
  const prettyType = prettifyType(type);
  if (prettyType.includes("\n")) {
    return `${prefix}: ${codeBlock(prettyType, "type", true)}`;
  } else {
    return `${prefix} ${codeBlock(prettyType, "type")}`;
  }
}
function prettifyType(type, options) {
  try {
    return convertToOriginalType(
      format(convertToValidType(type), {
        parser: "typescript",
        printWidth: 60,
        singleAttributePerLine: false,
        arrowParens: "avoid"
      })
    );
  } catch (e) {
    if (options?.throwOnError) {
      throw e;
    }
    return type;
  }
}
var convertToValidType = (type) => `type x = ${type.replace(/(.*)\.\.\.$/, (_, p1) => addMissingParentheses(p1)).replace(/^(\(.*\)): /, (_, p1) => `${p1} =>`).replaceAll(/... (\d{0,}) more .../g, (_, p1) => `___${p1}MORE___`).replaceAll(/... (\d{0,}) more ...;/g, (_, p1) => `___MORE___: ${p1};`).replaceAll("...;", "___KEY___: ___THREE_DOTS___;").replaceAll("...", "__THREE_DOTS__")};`;
var convertToOriginalType = (type) => type.replaceAll("___KEY___: ___THREE_DOTS___", "...;").replaceAll("__THREE_DOTS__", "...").replaceAll(/___MORE___: (\d{0,});/g, (_, p1) => `... ${p1} more ...;`).replaceAll(/___(\d{0,})MORE___/g, (_, p1) => `... ${p1} more ...`).replaceAll(/... (\d{0,}) more .../g, (_, p1) => `/* ${p1} more */`).replace(/type x =[ ]?((.|\n)*);.*/g, "$1").trim();

// src/formatDiagnosticMessage.ts
var formatDiagnosticMessage = (message, codeBlock) => {
  const formatTypeScriptBlock = (_, code) => codeBlock(code, "typescript");
  const formatSimpleTypeBlock = (_, code) => codeBlock(code, "type");
  const formatTypeOrModuleBlock = (_, prefix, code) => formatTypeBlock(
    prefix,
    ["module", "file", "file name"].includes(prefix.toLowerCase()) ? `"${code}"` : code,
    codeBlock
  );
  return message.replaceAll(
    /'(declare module )'(.*)';'/g,
    (_, p1, p2) => formatTypeScriptBlock(_, `${p1} "${p2}"`)
  ).replaceAll(
    /(is missing the following properties from type )'(.*)': (.+?)(?=and|$)/g,
    (_, pre, type, post) => `${pre}${formatTypeBlock("", type, codeBlock)}: <ul>${post.split(", ").filter(Boolean).map((prop) => `<li>${prop}</li>`).join("")}</ul>`
  ).replaceAll(
    /(types) '(.*?)' and '(.*?)'[\.]?/gi,
    (_, p1, p2, p3) => `${formatTypeBlock(p1, p2, codeBlock)} and ${formatTypeBlock(
      "",
      p3,
      codeBlock
    )}`
  ).replaceAll(
    /type annotation must be '(.*?)' or '(.*?)'[\.]?/gi,
    (_, p1, p2, p3) => `${formatTypeBlock(p1, p2, codeBlock)} or ${formatTypeBlock(
      "",
      p3,
      codeBlock
    )}`
  ).replaceAll(
    /(Overload \d of \d), '(.*?)', /gi,
    (_, p1, p2) => `${p1}${formatTypeBlock("", p2, codeBlock)}`
  ).replaceAll(/^'"[^"]*"'$/g, formatTypeScriptBlock).replaceAll(
    /(type|type alias|interface|module|file|file name|method's) '(.*?)'(?=[\s.])/gi,
    (_, p1, p2) => formatTypeOrModuleBlock(_, p1, p2)
  ).replaceAll(
    /(.*)'([^>]*)' (type|interface|return type|file|module)/gi,
    (_, p1, p2, p3) => `${p1}${formatTypeOrModuleBlock(_, "", p2)} ${p3}`
  ).replaceAll(
    /'((void|null|undefined|any|boolean|string|number|bigint|symbol)(\[\])?)'/g,
    formatSimpleTypeBlock
  ).replaceAll(
    /'(import|export|require|in|continue|break|let|false|true|const|new|throw|await|for await|[0-9]+)( ?.*?)'/g,
    (_, p1, p2) => formatTypeScriptBlock(_, `${p1}${p2}`)
  ).replaceAll(
    /(return|operator) '(.*?)'/gi,
    (_, p1, p2) => `${p1} ${formatTypeScriptBlock("", p2)}`
  ).replaceAll(
    /'((?:(?!:\s*}).)*?)' (?!\s*:)/g,
    (_, p1) => `${codeBlock(p1)} `
  );
};
export {
  formatDiagnosticMessage
};
